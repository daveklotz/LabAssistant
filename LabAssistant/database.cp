#include "lab assistant.h"#include "database.h"#include "mainMachineList.h"#include "error.h"#include <string.h>#include "machineRecord.h"#include "userRecord.h"extern GrafPtr	gMainPort;extern computerRecHdl		gMachineRecords;extern ListHandle			gMainWindowList;void LockMachineRecordHdl(void){	HLock((Handle) gMachineRecords);}void UnLockMachineRecordHdl(void){	HUnlock((Handle) gMachineRecords);}computerRecPtr GetMachineRecord(long machineArrayNumber){	return &(*gMachineRecords)[machineArrayNumber];}ListHandle GetListHandle(void){	return gMainWindowList;}Boolean FindEmptyMachine(short *machineNumber){	long 			counter, numberofComputers;	Boolean 		foundIt = false;	computerRecPtr	theComputer;		numberofComputers = GetNumberofMachines();			for(counter = 0; counter < numberofComputers; counter ++)              /* Search for computer number matched with entered computer number */	{		LockMachineRecordHdl();		theComputer = GetMachineRecord(counter);			if((!BitTst(&theComputer->status, kComputerInUse)) && 			BitTst(&theComputer->status, kComputerWorking) &&			(!BitTst(&theComputer->status, kTeachingSet)))		{			*machineNumber = theComputer->number;			foundIt = true;			break;		}	}		UnLockMachineRecordHdl();	return foundIt;}short CheckforRestriction(userNodePtr theUser){			if(BitTst(&(theUser->status), RestrictedUserBit))	{		if(BitTst(&(theUser->status), LevelOfRestrictionBit))			return (kFullRestriction);				return (kPartialRestriction);		}		if(BitTst(&(theUser->status), TempUserBit))		return (kTempUser);		return (kNoRestricition);}void UpdateMachines(computerRecPtr theComputer){	Rect				boxRect;	ListHandle			theList;		InvalRect(&(theComputer)->computerRect);		SetRect(&boxRect, 13, 9, 245, 26);	InvalRect(&boxRect);	SetRect(&boxRect, 383, 9, 615, 26);	InvalRect(&boxRect);		SetRect(&boxRect, 379, 268, 606, 424);	theList = GetListHandle();	HLock((Handle) theList);	InvalRect(&(*theList)->rView);	HUnlock((Handle) theList);		ComputerRecordSave();}long GetNumberofMachines(void){	short				numberofMachines;		HLock((Handle) gMachineRecords);	numberofMachines = GetHandleSize((Handle) gMachineRecords) / sizeof(computerRecord);	HUnlock((Handle) gMachineRecords);		return numberofMachines;}Boolean	FindMachineNumber(long machineNumber, long *machineArrayNumber){	long counter, numberofComputers;	Boolean 	foundIt = false;	computerRecPtr	theComputer;		numberofComputers = GetNumberofMachines();			for(counter = 0; counter < numberofComputers; counter ++)              /* Search for computer number matched with entered computer number */	{		LockMachineRecordHdl();		theComputer = GetMachineRecord(counter);		if(theComputer->number == (short) machineNumber)		{			*machineArrayNumber = counter;			foundIt = true;			break;		}	}	UnLockMachineRecordHdl();	return foundIt;}/*******************************************************************		Boolean Search(long  studentNumber, userNodePtr theUser)--------------------------------------------------------------------SYNOPSIS: This routine searches for the user with studentNumber          passed to it. It first checks the other user database,          if it is not found there it checks the main user database.CALLED BY: PASS: long	  studentRecord *	RETURN: Boolean  -  Was search succesful?DESTROYED: NothingREVISION HISTORY:	Name				Date		Description	----				----		-----------	Jeremy C Norberg	9/01/93		Initial version*********************************************************************/Boolean Search(long *studentNumber, userNodePtr theUser){	short				indexRefNum;	FSSpec				indexFileSpec;	long				indexNumber;	long				recordCount, fileSize;	Boolean				returnValue = false;		userNode			*userHead;			userHead = CreateUserList();	ReadUserInfo(userHead);		if(SearchOtherUser(userHead, theUser, *studentNumber))        /* Search other user database */	{		DeleteUserList(userHead);			/* If found user, return */		return true;				                 	}		DeleteUserList(userHead);		if(FSMakeFSSpec(0, 0, kUserDBIndexFileName, &indexFileSpec))	{			DoError("\pCannot search user database file. The Index file cannot be located. Turning off Database checking.", false);		//DatabaseChecking();		return false;	}		if(FSpOpenDF(&indexFileSpec, fsCurPerm, &indexRefNum))	{		DoError("\pCannot search user database file. The Index file cannot be opened. Turning off Database checking.", false);		//DatabaseChecking();		return false;	}		SetFPos(indexRefNum, fsFromStart, 0);		GetEOF(indexRefNum, &fileSize);		recordCount = fileSize / (sizeof(studentNumber) * 2);     /* determine the number of records in user database */     		/* Search user database for match */		if(SearchIndexFile(indexRefNum, studentNumber, 0, recordCount + 1, &indexNumber, &returnValue))	{		GetStudentRecord(theUser, indexNumber);		returnValue = true;	}		FSClose(indexRefNum);						return returnValue;}/*******************************************************************		Boolean SearchIndexFile(long recordLength, short indexRefNum,             long studentNumber, long begin, long end, studentRecord *theStudent)--------------------------------------------------------------------SYNOPSIS: This routine using a binary recursive search of the User 	      Index File for a match of studentNumber.CALLED BY: Search() "files.c"PASS: long      short      long      long      long	  studentRecord *	RETURN: Boolean  -  Was search succesful?DESTROYED: NothingREVISION HISTORY:	Name				Date		Description	----				----		-----------	Jeremy C Norberg	9/01/93		Initial version*********************************************************************/Boolean SearchIndexFile(short indexRefNum, long *studentNumber, long begin, long end, long *indexNumber, Boolean *returnValue){	long		tempStudentNumber, tempIndexNumber, middle, tempLength;	OSErr		theError;		if (begin > end)	{			*returnValue = false;		return *returnValue;	}		middle = (begin + end) / 2L;		SetFPos(indexRefNum, fsFromStart, middle * sizeof(long) * 2);		tempLength = sizeof(tempStudentNumber);		theError = FSRead(indexRefNum, &tempLength, &tempStudentNumber);	theError = FSRead(indexRefNum, &tempLength, &tempIndexNumber);		if (tempStudentNumber == *studentNumber)	{			*indexNumber = tempIndexNumber;		*returnValue = true;		return *returnValue;	}		if (*studentNumber < tempStudentNumber)	{		SearchIndexFile(indexRefNum, studentNumber, begin, -- middle, indexNumber, returnValue);	}	else	{		SearchIndexFile(indexRefNum, studentNumber, ++ middle, end, indexNumber, returnValue);	}		return *returnValue;}void GetStudentRecord(userNodePtr theUser, long indexNumber){	long		tempLength;	FSSpec		dbFileSpec;	short		dbRecordLength, dbRefNum;		if(FSMakeFSSpec(0, 0, kUserDBFileName, &dbFileSpec))		DoError("\pError Finding Database File.", true);		if(FSpOpenDF(&dbFileSpec, fsRdPerm, &dbRefNum))		DoError("\pError Opening Database File.", true);		dbRecordLength = sizeof(userNode);		SetFPos(dbRefNum, fsFromStart, indexNumber * dbRecordLength);		tempLength = dbRecordLength;		FSRead(dbRefNum, &tempLength, theUser);		FSClose(dbRefNum);}