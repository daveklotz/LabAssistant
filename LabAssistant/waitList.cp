#include <string.h>#include <stdio.h>//#include <Files.h>#include "Lab Assistant.h"#include "userRecord.h"#include "Norm_Files.h"#include "waitList.h"#include "error.h"#include "checkIn.h"#include "dialog.h"#include "Menu.h"#include "interface.h"OSErr WaitList::ReadListFromFile(void){	short 		fRefNum;	FSSpec		fileSpec;	OSErr		theError;	long		inOutCount;	userNode	theUser;	userNodePtr	newPtr;	extern char gFeatureFlag;		listPtr = &theWaitListHead;		theError = FSMakeFSSpec(0, 0, kWaitListFileName, &fileSpec);		if(theError)		return theError;			theError = FSpOpenDF(&fileSpec, fsCurPerm, &fRefNum);		if(theError)		return theError;		inOutCount = sizeof(userNode);	theError = FSRead(fRefNum, &inOutCount, &theUser);			if (theUser.next == NULL)	{		theError = FSClose(fRefNum);		BitClr(&gFeatureFlag, 5);		return theError;	}				while(theError != -39)	{		inOutCount = sizeof(userNode);		theError = FSRead(fRefNum, &inOutCount, &theUser);				//if (listPtr->next == NULL)		//{		//	theError = FSClose(fRefNum);		//	return theError;		//}				if (inOutCount == sizeof(userNode))		//	AddUser(theUser);		{			//newPtr = new userNode;			newPtr = (userNodePtr)NewPtr(sizeof(userNode));			memcpy(newPtr, &theUser, sizeof(userNode));			listPtr->next = newPtr;			newPtr->next = NULL;			listPtr = newPtr;		}				}		theError = FSClose(fRefNum);		BitSet(&gFeatureFlag, 5);	return theError;}Boolean WaitList::AddUser(userNode theUser){	userNodePtr		userPtr;	extern char 	gFeatureFlag;		//check for duplicates: CheckForUser()	if (CheckForUser(theUser))		return false;		//userPtr = new userNode;	userPtr = (userNodePtr)NewPtr(sizeof(userNode));			listPtr = &theWaitListHead;	while(listPtr->next != NULL)		listPtr = listPtr->next;			memcpy(userPtr, &theUser, sizeof(userNode));		listPtr->next = userPtr;	userPtr->next = NULL;		if(!BitTst(&gFeatureFlag,5))		BitSet(&gFeatureFlag,5);	return true;	}Boolean WaitList::CheckForUser(userNode theUser){	userNodePtr 	userPtr;		userPtr = &theWaitListHead;	while (userPtr != NULL)	{		if(theUser.studentNumber == userPtr->studentNumber)		{			return true;		}		userPtr = userPtr->next;	}		return false;}OSErr WaitList::WriteListToFile(void){	short 			fRefNum;	FSSpec			fileSpec, tempFileSpec;	OSErr			theError;	long			inOutCount;	Str255			tempFileName;	userNodePtr		theUser;		CreateTempFileName(tempFileName);	theError = FSMakeFSSpec(0, 0, kWaitListFileName, &fileSpec);	if (theError)	{		theError = FSpCreate(&fileSpec, kCreatorType, 'NMDB', (ScriptCode) -1);			}		theError = FSMakeFSSpec(0, 0, tempFileName, &tempFileSpec);	if(theError)	{		theError = FSpCreate(&tempFileSpec, kCreatorType, 'TEMP', (ScriptCode) -1);	}		theError = FSpOpenDF(&tempFileSpec, fsCurPerm, &fRefNum);		theUser = &theWaitListHead;		//if (theWaitListHead.next != NULL)	//	theUser = theWaitListHead.next;	//else	//	theUser = &theWaitListHead;		//theUser = theUser->next;		while(theUser != NULL)	{		inOutCount = sizeof(userNode);				theError = FSWrite(fRefNum, &inOutCount, theUser);				theUser = theUser->next;	} 		//inOutCount = sizeof(userNode);							//pick up the last node			//theError = FSWrite(fRefNum, &inOutCount, theUser);		//and write it			theError = FSpExchangeFiles(&fileSpec, &tempFileSpec);	theError = FSClose(fRefNum);		theError = FSpDelete(&tempFileSpec);		return(theError);	}		//***************************************************************//					Public Methods//***************************************************************		WaitList::WaitList(){	extern char gFeatureFlag;		theWaitListHead.next = NULL;	ReadListFromFile();	listPtr = &theWaitListHead;	if (theWaitListHead.next == NULL)		BitClr(&gFeatureFlag, kWaitingListCheck);}WaitList::~WaitList(){	userNodePtr			deletePtr;		listPtr = theWaitListHead.next;	deletePtr = theWaitListHead.next;		while(listPtr != NULL)	{		listPtr = deletePtr->next;		//delete deletePtr;		DisposePtr((Ptr)deletePtr);		deletePtr = listPtr;	}	theWaitListHead.next = NULL;}		Boolean WaitList::WaitListAdd(userNode theUser){	if (!AddUser(theUser))		return false;	WriteListToFile();		return (true);}Boolean WaitList::CheckInFromWaitList(void){		dialogRecordHdl		dialogRecord;	userNodePtr			deletePtr;		listPtr = theWaitListHead.next;	//listPtr = listPtr->next;	//dialogRecord = (dialogRecordHdl)NewHandle(sizeof(dialogRecordHdl));	dialogRecord = CreateDialogRec(NULL, kEventCheckIn, listPtr->studentNumber, ok, -99);			CheckInCallBack(dialogRecord);			deletePtr = listPtr;		listPtr = listPtr->next;	theWaitListHead.next = listPtr;	//delete deletePtr;	DisposePtr((Ptr)deletePtr);		WriteListToFile();		return true;}Boolean WaitList::IsThereAWaitList(){	if (theWaitListHead.next == NULL) 		return false;			else 		return true;}	void WaitList::PutAtFrontOfList(userNode theUser){	userNodePtr		newNode;		listPtr = &theWaitListHead;	//newNode = new userNode;	newNode = (userNodePtr)NewPtr(sizeof(userNode));		memcpy(newNode, &theUser, sizeof(userNode));	newNode->next = theWaitListHead.next;	theWaitListHead.next = newNode;		WriteListToFile();}		void	WaitList::WaitlistBoxSetup(void){	GrafPtr			oldPort;	DialogPtr		theDialog;	winRefConRecHdl	refCon;	short			itemType;	Handle			itemHandle;	Rect			itemRect;	ListHandle		theList;	Rect 			listSize;	Point			cellSize, theCell;	userNode		*userRecordList;	employeeNode	*employeeRecordList;	Byte			theEvent;	char			name[31];	short			row = 0;	RGBColor		backColor;		listPtr = theWaitListHead.next;		DisableMenus(true);	GetPort(&oldPort);		theDialog = GetNewDialog(137, nil, (WindowPtr)-1L);		SetPort(theDialog);	backColor.red = 65535;	backColor.green = 65535;	backColor.blue = 65535;		RGBBackColor(&backColor);	ShowWindow(theDialog);			GetDItem(theDialog, 2, &itemType, &itemHandle, &itemRect);	SetRect(&listSize, 0, 0, 1, 0);	SetPt(&cellSize, 0, 0);		theList = LNew(&itemRect, &listSize, cellSize, 0, theDialog, true, false, false, true);		itemRect.right += 15;	InsetRect(&itemRect, -2, -2);		Add3dRaised(&itemRect, true, true, true);		refCon = (winRefConRecHdl) NewHandle(sizeof(winRefConRec));        // Create Ptr to refCon record		HLock((Handle) refCon);	(*refCon)->windowID = 137;                          // Assign the WindowID	(*refCon)->dialogRecord = NULL;	(*refCon)->oldPort = (long) oldPort; 							// Assign the misc field to the oldPort. This required when closeing dialog box	(*refCon)->list = (long) theList;                              	HUnlock((Handle) refCon);		SetWTitle(theDialog, "\pWaiting List");		while (listPtr != NULL)	{		LAddRow(1, row, theList);		sprintf(name, "%s", listPtr->name);		SetPt(&theCell, 0, row);		LSetCell(name, strlen(name), theCell, theList);		row++;		listPtr = listPtr->next;	}	LDoDraw(true, theList);		SetPt(&theCell, 0, 0);	LSetSelect(true, theCell, theList);		SetWRefCon(theDialog, (long) refCon);  		GetDItem(theDialog, ok, &itemType, &itemHandle, &itemRect);	HiliteControl((ControlHandle) itemHandle, 255);		GetDItem(theDialog, 3, &itemType, &itemHandle, &itemRect);	SetDItem(theDialog, 3, itemType, (Handle) DrawOKOutline, &itemRect);	                       	LUpdate((*theList)->port->visRgn, theList);	}	void WaitList::WaitlistBoxEvent(EventRecord *theEvent){	WindowPtr			theDialog, oldPort;	winRefConRecHdl		refCon;	Handle				okButtonHandle;	short				itemType, itemHit = 0;	Rect				itemRect;   	char				theKey;	Boolean				done = false, cellSelected;	dialogRecordHdl		dialogRecord;	dialogProcPtr		callBack;	Point				clickLocation, theCell;	ListHandle			theList;		userNode			*theUserList;				short				len;	char 				searchName[31];	long 				oldMisc;	theDialog = FrontWindow();		refCon = (winRefConRecHdl) GetWRefCon(theDialog);        // Get the Window Ref Record from the Windows Ref Con	HLock((Handle) refCon);	oldPort = (WindowPtr) (*refCon)->oldPort;	dialogRecord = (dialogRecordHdl) (*refCon)->dialogRecord;	theList = (ListHandle) (*refCon)->list;	HUnlock((Handle) refCon);		GetDItem(theDialog, ok, &itemType, &okButtonHandle, &itemRect);	HiliteControl((ControlHandle) okButtonHandle, 0);		switch(theEvent->what)	{		case updateEvt:			LUpdate((*theList)->port->visRgn, theList);			break;	}		if(!done)	{			if(!DialogSelect(theEvent, (DialogPtr *) &theDialog, &itemHit))			return;                // Nothing to Handle, just return.	}                                	switch (itemHit)	{		case ok:					HUnlock((Handle) dialogRecord);			//move up to case ok and repeat?			DisableMenus(false);			DisposeDialog(theDialog);			DisposeHandle((Handle) refCon);			SetPort(oldPort);	}		return;}					//place holdr		