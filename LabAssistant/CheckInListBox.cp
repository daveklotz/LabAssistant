#include <string.h>#include <stdio.h>#include "lab assistant.h"#include "CheckInListBox.h"#include "interface.h"void CheckInListBoxSetup(dialogRecordHdl dialogRecord){	GrafPtr			oldPort;	DialogPtr		theDialog;	winRefConRecHdl	refCon;	short			itemType;	Handle			itemHandle;	Rect			itemRect;	ListHandle		theList;	Rect 			listSize;	Point			cellSize, theCell;	userNode		*userRecordList;	employeeNode	*employeeRecordList;	Byte			theEvent;	char			name[31];	short			row = 0;	RGBColor		backColor;		GetPort(&oldPort);		theDialog = GetNewDialog(133, nil, (WindowPtr)-1L);  //133 = "List Employee/User"		SetPort(theDialog);	backColor.red = 65535;	backColor.green = 65535;	backColor.blue = 65535;		RGBBackColor(&backColor);	ShowWindow(theDialog);		GetDItem(theDialog, 5, &itemType, &itemHandle, &itemRect);	SetRect(&listSize,0,0,1,0);	SetPt(&cellSize,0,0);		theList = LNew(&itemRect, &listSize, cellSize, 0, theDialog, true, false, false, true);		itemRect.right += 15;	InsetRect(&itemRect, -2, -2);		Add3dRaised(&itemRect, true, true, true);		refCon = (winRefConRecHdl) NewHandle(sizeof(winRefConRec));        // Create Ptr to refCon record		HLock((Handle) refCon);	(*refCon)->windowID = kEditListBoxID;                          // Assign the WindowID	(*refCon)->dialogRecord = dialogRecord;	(*refCon)->oldPort = (long) oldPort; 							// Assign the misc field to the oldPort. This required when closeing dialog box	(*refCon)->list = (long) theList;                              	HUnlock((Handle) refCon);	HLock((Handle) dialogRecord);	if((theEvent = (*dialogRecord)->theEvent) == kEventUserList)	{			SetWTitle(theDialog, "\pEdit User Data");		userRecordList = (userNode *) (*dialogRecord)->theRecord;	}	else	{		SetWTitle(theDialog, "\pEdit Employee Data");		employeeRecordList = (employeeNode *) (*dialogRecord)->theRecord;	}			HUnlock((Handle) dialogRecord);		(*theList)->selFlags = 190;		if(theEvent == kEventUserList)	{		userRecordList = userRecordList->next;				while(userRecordList != userRecordList->next)		{			LAddRow(1, row, theList);			sprintf(name, "%s", userRecordList->name);							SetPt(&theCell, 0, row);			LSetCell(name, strlen(name), theCell, theList);						row ++;						userRecordList = userRecordList->next;		}	}	else	{		employeeRecordList = employeeRecordList->next;				while(employeeRecordList != employeeRecordList->next)		{			LAddRow(1, row, theList);			sprintf(name, "%s", employeeRecordList->name);							SetPt(&theCell, 0, row);			LSetCell(name, strlen(name), theCell, theList);						row ++;						employeeRecordList = employeeRecordList->next;		}	}		LDoDraw(true, theList);		SetPt(&theCell, 0, 0);	LSetSelect(true, theCell, theList);		SetWRefCon(theDialog, (long) refCon);                          // Set the WindowRefCon	LUpdate((*theList)->port->visRgn, theList);	}void CheckInListBoxBoxEvent(EventRecord *theEvent){	WindowPtr			theDialog, oldPort;	winRefConRecHdl		refCon;	Handle				itemHandle;	short				itemType, itemHit = 0;	Rect				itemRect;   	char				theKey;	Boolean				done = false, cellSelected;	dialogRecordHdl		dialogRecord;	dialogProcPtr		callBack;	Point				clickLocation, theCell;	ListHandle			theList;	short 				counter;	theDialog = FrontWindow();		refCon = (winRefConRecHdl) GetWRefCon(theDialog);        // Get the Window Ref Record from the Windows Ref Con	HLock((Handle) refCon);	oldPort = (WindowPtr) (*refCon)->oldPort;	dialogRecord = (dialogRecordHdl) (*refCon)->dialogRecord;	theList = (ListHandle) (*refCon)->list;	HUnlock((Handle) refCon);		HLock((Handle) dialogRecord);	callBack = (*dialogRecord)->callBack;	HUnlock((Handle) dialogRecord);			switch(theEvent->what)          							 //Handle Keys before passing off to Dialog Select	{		case mouseDown:			memcpy(&clickLocation, &theEvent->where, sizeof(Point));			GlobalToLocal(&clickLocation);			LClick(clickLocation, theEvent->modifiers, theList);			for(counter = 2; counter <= 4; counter ++)			{				GetDItem(theDialog, counter, &itemType, &itemHandle, &itemRect);				if(PtInRect(clickLocation, &itemRect))				{					itemHit = counter;					done = true;					break;				}			}			break;		case updateEvt:			LUpdate((*theList)->port->visRgn, theList);			break;		case keyDown:		case autoKey:			theKey = theEvent->message & charCodeMask;       			 // Mask out the char from the event message			switch (theKey)			{				case '\r':			// Return				case '\003':		// Enter					itemHit = ok;					done = true;					break;				case '\033':		// ESC					itemHit = ok;					done = true;					break;			}		}	if(!done)	{			if(!DialogSelect(theEvent, (DialogPtr *) &theDialog, &itemHit))			return;                // Nothing to Handle, just return.	}                                		SetPt(&theCell, 0, 0);		cellSelected = LGetSelect(true, &theCell, theList);		switch (itemHit)	{		case 3:		case 4:				if(!cellSelected)				break;		case 2:		case ok:			HLock((Handle) dialogRecord);			(*dialogRecord)->misc = theCell.v;			(*dialogRecord)->itemHit = itemHit;			HUnlock((Handle) dialogRecord);			LDispose(theList);			DisposeDialog(theDialog);			DisposeHandle((Handle) refCon);			SetPort(oldPort);						callBack(dialogRecord);			break;	}}