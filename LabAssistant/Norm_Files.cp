#include "lab assistant.h"#include "Norm_Files.h"#include "error.h"#include "employeeRecord.h"#include <string.h>extern char				gFeatureFlag;/*******************************************************************		void WriteUsageLog(computerRecord theComputer, long consultantOutStudentNumber)--------------------------------------------------------------------SYNOPSIS: This routine reads the computer record information from a           file called "Computer Log". The information contains the          current user of the computer, and all information contained          in a computerRecord.CALLED BY: DoTransfer() "user.c"		   DoCheckOut() "user.c"           PASS: short	  char *	  Boolean	RETURN: NothingDESTROYED: NothingREVISION HISTORY:	Name				Date		Description	----				----		-----------	Jeremy C Norberg	9/01/93		Initial version*********************************************************************/void WriteUsageLog(computerRecPtr theComputer){	short	fileRefNum;	FSSpec	fileSpec;		Str255	tempString;	long	currentTime;	short	tempNumber;			/***** 	  Check to see if Usage Log file exists:	     if it doesn't then create one and add a header of field names to top of file	     if it does open it	*****/		if(FSMakeFSSpec(0, 0, "\pUsage Log", &fileSpec) == -43)	{			FSpCreate(&fileSpec, 'NORM', 'TEXT', (ScriptCode) -1);		FSpOpenDF(&fileSpec, fsRdWrPerm, &fileRefNum);				strcpy((char *) tempString, "Computer_Number\tStudent_Number\tStudent_Name\tRestricted\tUser_Type\tPriority\tDate_On\tTime_On\tConsultant_On\tDate_Out\tTime_Out\tConsultant_Out");				DataFileWrite(fileRefNum, (char *) tempString, true);	}	else	{		FSpOpenDF(&fileSpec, fsRdWrPerm, &fileRefNum);	}		SetFPos(fileRefNum, fsFromLEOF, 0);		NumToString(theComputer->number, tempString);	PtoCstr(tempString);	DataFileWrite(fileRefNum, (char *) tempString, false);		NumToString((theComputer->userInfo).studentNumber, tempString);	PtoCstr(tempString);	DataFileWrite(fileRefNum, (char *) tempString, false);	                                                                                                                                                                           	strcat(theComputer->userInfo.name, "\0");	strncpy((char *) tempString, theComputer->userInfo.name, sizeof((theComputer->userInfo).name));	DataFileWrite(fileRefNum, (char *) tempString, false);		if(BitTst(&(theComputer->userInfo.status), RestrictedUserBit))		DataFileWrite(fileRefNum, "1", false);	else		DataFileWrite(fileRefNum, "0", false);		tempNumber = (BitTst(&(theComputer->userInfo.status), UserTypeBit) * 1) +				 (BitTst(&(theComputer->userInfo.status), TempUserBit) * 2);	NumToString((long) tempNumber, tempString);	PtoCstr(tempString);	DataFileWrite(fileRefNum, (char *) tempString, false);		tempString[0] = theComputer->userInfo.priority + 48;	tempString[1] = 0;	DataFileWrite(fileRefNum, (char *) tempString, false);		IUDateString ( theComputer->timeOn, shortDate, tempString );	PtoCstr(tempString);	DataFileWrite(fileRefNum, (char *) tempString, false);		IUTimeString(theComputer->timeOn, false, tempString);	PtoCstr(tempString);	DataFileWrite(fileRefNum, (char *) tempString, false);		NumToString(theComputer->employeeNumber, tempString);	PtoCstr(tempString);	DataFileWrite(fileRefNum, (char *) tempString, false);		GetDateTime((unsigned long *) &currentTime);	IUDateString(currentTime, shortDate, tempString );	PtoCstr(tempString);	DataFileWrite(fileRefNum, (char *) tempString, false);		IUTimeString(currentTime, false, tempString);	PtoCstr(tempString);	DataFileWrite(fileRefNum, (char *) tempString, false);		NumToString(GetActiveEmployee(), tempString);	//NumToString(theComputer->employeeNumber, tempString);	PtoCstr(tempString);	DataFileWrite(fileRefNum, (char *) tempString, true);		FSClose(fileRefNum);		FlushVol(nil, 0);	}/*******************************************************************		OSErr DataFileWrite(short fRefNum, char *writeString, Boolean returnTerminate)--------------------------------------------------------------------SYNOPSIS: This routine reads the computer record information from a           file called "Computer Log". The information contains the          current user of the computer, and all information contained          in a computerRecord.CALLED BY: WriteUsageLog() "files.c"           PASS: short	  char *	  Boolean	RETURN: OSErrDESTROYED: NothingREVISION HISTORY:	Name				Date		Description	----				----		-----------	Jeremy C Norberg	9/01/93		Initial version*********************************************************************/OSErr DataFileWrite(short fRefNum, char *writeString, Boolean returnTerminate){	long	length = 1;	char	terminator;	OSErr	theError;	Str255	theErrorString;		length = strlen(writeString);		theError = FSWrite(fRefNum, &length, writeString);				if(theError)		{				NumToString(theError, theErrorString);			ParamText(theErrorString,nil,nil,nil);						//DoError("\Problem writing to data file", false);			return theError;		}			if(returnTerminate)	{		length = 1;		terminator = 13;		FSWrite(fRefNum, &length, &terminator);	}	else	{		length = 1;		terminator = 9;		FSWrite(fRefNum, &length, &terminator);	}		return (theError);}/*******************************************************************		void StudentRecordParse(char *record, studentRecord *theStudent)--------------------------------------------------------------------SYNOPSIS: This routine takes a raw data string from the original           user lists and creates a studentRecord.CALLED BY: ReadFromBuffer() "files.c"PASS: char *	  studentRecord *	RETURN: NothingDESTROYED: NothingREVISION HISTORY:	Name				Date		Description	----				----		-----------	Jeremy C Norberg	9/01/93		Initial version*********************************************************************/void StudentRecordParse(char *record, userNodePtr theUser){	Str255			tempString;	long			counter;		strncpy((char *) tempString, record + 3, 7);	tempString[7] = 0;	CtoPstr((char *) tempString);	StringToNum(tempString, &(theUser->studentNumber));		for(counter = 0; counter <= 30; counter ++)		theUser->name[counter] = 0;		memcpy(&theUser->name, record + 10, 30);		memcpy(&theUser->gender, record + 51, 1);		BitClr(&(theUser->status), RestrictedUserBit);    /* Set status to no restriction */	BitClr(&(theUser->status), UserTypeBit);			 /* Set user type to regular */	BitClr(&(theUser->status), TempUserBit);			 /* Set user to not a temp */		if(theUser->priority == 3)		return;		strncpy((char *) tempString, record + 75, 4);        /* Check to see if user is taking an ENGR class or CSE 142 to set priority to 1 */	if(memcmp((char *) &tempString,"ENGR", 4) == 0)	{		theUser->priority = 1;	}	else	{		strncpy((char *) tempString, record + 75, 4);		if(memcmp((char *) &tempString,"CSE ", 4) == 0)		{			strncpy((char *) tempString, record + 61, 3);			if(memcmp((char *) &tempString,"142", 3) == 0)			{				theUser->priority = 1;			}		}	}}/*******************************************************************		short FindRecordLength(short fRefNum)--------------------------------------------------------------------SYNOPSIS: This routine returns the record length from a data file.CALLED BY: ReadFromBuffer() "files.c"PASS: short fRefNum: file Reference Number	RETURN: short : record length of fileDESTROYED: NothingREVISION HISTORY:	Name				Date		Description	----				----		-----------	Jeremy C Norberg	9/01/93		Initial version*********************************************************************/short FindRecordLength(short fRefNum){	long 				tempLength;	char				tempChar;	short				counter, recordLength;	SetFPos(fRefNum, fsFromStart, 0);               /* Set file position marker to 0 */			tempLength = 1;		for(counter = 0; counter < 255; counter ++)     /* Record Length can't excide 255 char */	{		if(FSRead(fRefNum, &tempLength, &tempChar))		{			//DoError("\pError reading database file while checking record size.", true);			}				if (tempChar == 13)                        /* if ASCII = 13 then found end of file */		{			recordLength = counter + 1;			break;		}	}		SetFPos(fRefNum, fsFromStart, 0);                 /* Set file position marker to 0 */             		return recordLength;}/*******************************************************************		short ReadInBuffer(Handle *buffer, short *refNum, long *size)--------------------------------------------------------------------SYNOPSIS: This reads in database record into buffer for the merge routine.CALLED BY: ReadFromBuffer() "files.c"PASS: Handle *buffer  : handle to the buffer to store records in	  short *refNum   : database files reference number	  long *size      : size of buffer to read inRETURN: short		  : read data size > 0 (true/false)REVISION HISTORY:	Name				Date		Description	----				----		-----------	Jeremy C Norberg	9/01/93		Initial version*********************************************************************/short ReadInBuffer(Handle *buffer, short *refNum, long *size){	long inOutCount = *size;               /* set size of buffer to read in */	OSErr theError;		HLock(*buffer);	theError = FSRead(*refNum, &inOutCount, **(buffer));	HUnlock(*buffer);		if(theError == eofErr)                 /* if reach the end of file, return back how much read in */	{		*size = inOutCount;				if(inOutCount == 0L)			return 0;	}	else if(theError)	{		//DoError("\pError Reading Buffer.", true);	}		return 1;}/*******************************************************************		Boolean WriteOutBuffer(Handle *buffer, short *refNum, long *size)--------------------------------------------------------------------SYNOPSIS: This writes out database records from a buffer for the merge routine.CALLED BY: ReadFromBuffer() "files.c"PASS: Handle *buffer  : handle to the buffer to store records in	  short *refNum   : database files reference number	  long *size      : size of buffer to read inRETURN: short		  : read data size > 0 (true/false)REVISION HISTORY:	Name				Date		Description	----				----		-----------	Jeremy C Norberg	9/01/93		Initial version*********************************************************************/Boolean WriteOutBuffer(Handle *buffer, short *refNum, long *size){	long inOutCount = *size;               /* set size of buffer to write out */	OSErr	theError;		HLock(*buffer);	theError = FSWrite(*refNum, &inOutCount, **(buffer));	HUnlock(*buffer);		if(theError)	{		//DoError("\pError Writing Buffer.", true);		return true;	}		return false;}/*******************************************************************		void Merge(StandardFileReply *input_1_FileReply, StandardFileReply *input_2_FileReply)--------------------------------------------------------------------SYNOPSIS: This routine merges the two raw student lists into a binary		  database file with studentRecord records.CALLED BY: ReadFromBuffer() "files.c"PASS: StandardFileReply *input_1_FileReply  : ptr to file info record for engr raw db	  StandardFileReply *input_2_FileReply  : ptr to file info record for other raw dbRETURN: nothingREVISION HISTORY:	Name				Date		Description	----				----		-----------	Jeremy C Norberg	9/01/93		Initial version*********************************************************************/void Merge(StandardFileReply *input_1_FileReply, StandardFileReply *input_2_FileReply){	short	input_1_RefNum, input_2_RefNum, outputRefNum;	FSSpec	outputFileSpec;		Handle	input_1_Buffer, input_2_Buffer, outputBuffer;		long	input_1_Size, input_2_Size, outputSize;	long	input_1_Counter = 0, input_2_Counter = 0, outputCounter = 0;	short   input_1_RecordLength, input_2_RecordLength, outputRecordLength;		userNode	student_1, student_2;	OSErr	theError;		Boolean	done = false;			/***********************	 Open engr raw db and other raw db and create User Database file 	***********************/		theError = FSpOpenDF(&input_1_FileReply->sfFile, fsCurPerm, &input_1_RefNum);		if(theError)	{			DoError("\pError Open Input File 1 Database File.", false);		return;	}		if(FSpOpenDF(&input_2_FileReply->sfFile, fsCurPerm, &input_2_RefNum))	{			DoError("\pError Open Input File 2 Database File.", false);		return;	}		if((FSMakeFSSpec (0, 0, "\pUser Database", &outputFileSpec)) != -43)	{		if(FSpDelete(&outputFileSpec))		{			DoError("\pError Deleting Old Database File.", false);			return;		}	}			if(FSpCreate(&outputFileSpec, 'NORM', 'NMDB', (ScriptCode) -1))	{		DoError("\pError Creating New Database File.", false);		return;	}				if(FSpOpenDF(&outputFileSpec, fsCurPerm, &outputRefNum))	{			DoError("\pError Opening New Database File.", false);		return;	}		/***********************	 - find record lengths of the engr raw db and other raw db	 - find the numbder of records	***********************/		input_1_RecordLength = FindRecordLength(input_1_RefNum);	input_2_RecordLength = FindRecordLength(input_2_RefNum);	outputRecordLength   = sizeof(userNode);		/***********************	 - Create buffer areas for each raw db and the output buffer	***********************/		input_1_Buffer = NewHandle(kRecordNumber * input_1_RecordLength);	input_2_Buffer = NewHandle(kRecordNumber * input_2_RecordLength);	outputBuffer   = NewHandle(kRecordNumber * outputRecordLength);		input_1_Size = GetHandleSize(input_1_Buffer);	input_2_Size = GetHandleSize(input_2_Buffer);	outputSize = GetHandleSize(outputBuffer);		/***********************	 - Read first buffer into memory from engr and other db	***********************/		ReadInBuffer(&input_1_Buffer, &input_1_RefNum, &input_1_Size);	ReadInBuffer(&input_2_Buffer, &input_2_RefNum, &input_2_Size);			/***********************	 - Read in first record from buffer from engr and other db	***********************/		ReadFromBuffer(&student_1, &input_1_Buffer, &input_1_RefNum, &input_1_Size, &input_1_Counter, &input_1_RecordLength);	ReadFromBuffer(&student_2, &input_2_Buffer, &input_2_RefNum, &input_2_Size, &input_2_Counter, &input_2_RecordLength);		/***********************	 - Loop until all records have been read.	   Each raw engr and other file are already sorted. 	   This block does a merge sort into one file. 	***********************/		while(!done)	{		if(student_1.studentNumber >= student_2.studentNumber)		{			WriteToBuffer(&student_2, &outputBuffer, &outputRefNum, &outputSize, &outputCounter, &outputRecordLength, false);			if(ReadFromBuffer(&student_2, &input_2_Buffer, &input_2_RefNum, &input_2_Size, &input_2_Counter, &input_2_RecordLength))			{				WriteToBuffer(&student_1, &outputBuffer, &outputRefNum, &outputSize, &outputCounter, &outputRecordLength, false);								while(!ReadFromBuffer(&student_1, &input_1_Buffer, &input_1_RefNum, &input_1_Size, &input_1_Counter, &input_1_RecordLength))				{					WriteToBuffer(&student_1, &outputBuffer, &outputRefNum, &outputSize, &outputCounter, &outputRecordLength, false);				}								WriteToBuffer(&student_1, &outputBuffer, &outputRefNum, &outputSize, &outputCounter, &outputRecordLength, true);								done = true;			}		}		else		{			WriteToBuffer(&student_1, &outputBuffer, &outputRefNum, &outputSize, &outputCounter, &outputRecordLength, false);			if(ReadFromBuffer(&student_1, &input_1_Buffer, &input_1_RefNum, &input_1_Size, &input_1_Counter, &input_1_RecordLength))			{				WriteToBuffer(&student_2, &outputBuffer, &outputRefNum, &outputSize, &outputCounter, &outputRecordLength, false);				while(!ReadFromBuffer(&student_2, &input_2_Buffer, &input_2_RefNum, &input_2_Size, &input_2_Counter, &input_2_RecordLength))				{					WriteToBuffer(&student_2, &outputBuffer, &outputRefNum, &outputSize, &outputCounter, &outputRecordLength, false);				}								WriteToBuffer(&student_2, &outputBuffer, &outputRefNum, &outputSize, &outputCounter, &outputRecordLength, true);								done = true;			}		}	}		FSClose(input_1_RefNum);	FSClose(input_2_RefNum);	FSClose(outputRefNum);		DisposHandle(input_1_Buffer);	DisposHandle(input_2_Buffer);	DisposHandle(outputBuffer);		FlushVol(nil, 0);		CreateIndex();              /* Create Index from User Database File */}/*******************************************************************		Boolean ReadFromBuffer(studentRecord *theStudent, Handle *buffer, short *fileRefNum, 							   long *size, long *counter, short *recordLength)--------------------------------------------------------------------SYNOPSIS: This routine reads a studentRecord from a buffer used in the Merge Routine.CALLED BY: ReadFromBuffer() "files.c"PASS: studentRecord *theStudent  : ptr to the record being read from buffer	  Handle *buffer             : handle to the buffer being read from	  short *fileRefNum          : file ref number of the raw db file buffer came from	  long *size                 : size of buffer read from file	  long *counter              : counter of what record in buffer reading from	  short *recordLength        : legnth of the record in raw db file buffer came fromRETURN: Boolean                  : can't read any more (true/false)REVISION HISTORY:	Name				Date		Description	----				----		-----------	Jeremy C Norberg	9/01/93		Initial version*********************************************************************/Boolean ReadFromBuffer(userNodePtr theStudent, Handle *buffer, short *fileRefNum, long *size, long *counter, short *recordLength){	short   returnResult = 1;	char	tempBuffer[120];		if((*counter) >= (*size))                      /* if record needed is large than the size of buffer read in next buffer from file */	{			*counter = 0;		returnResult = ReadInBuffer(buffer, fileRefNum, size);				if(returnResult == 0)                    /* if no more record to read then where done */	 	 	return true;	}		HLock(*buffer);	memcpy(tempBuffer, **buffer + (*counter), *recordLength);	HUnlock(*buffer);		if(*recordLength < 60)                      /* determine if the buffer being worked on is an engr db or other db */	{		theStudent->priority = 3;               /* working on other db buffer, set student priority to 3 */	}	else	{		theStudent->priority = 2;               /* working on engr db buffer, set student priority to 2 */	}		StudentRecordParse(tempBuffer, theStudent);   /* from raw data parse into a studentRecord */			(*counter) += (long) (*recordLength);          /* increment the record counter */		return false;                                 /* can read more */}/*******************************************************************		Boolean WriteToBuffer(studentRecord *theStudent, Handle *buffer, 		                      short *refNum, long *size, long *counter, 		                      short *recordLength, Boolean flush)--------------------------------------------------------------------SYNOPSIS: This routine writes a studentRecord to a buffer from the merge routine.           CALLED BY: ReadFromBuffer() "files.c"PASS: studentRecord *theStudent  : ptr to the record being written to buffer	  Handle *buffer             : handle to the buffer being writen to	  short *fileRefNum          : file ref number of output file	  long *size                 : size of buffer writen to file	  long *counter              : counter of what record in buffer writing to	  short *recordLength        : legnth of the record in raw db file buffer came from	  Boolean flush              : Flush the buffer to disk?RETURN: Boolean                  : error?REVISION HISTORY:	Name				Date		Description	----				----		-----------	Jeremy C Norberg	9/01/93		Initial version*********************************************************************/Boolean WriteToBuffer(userNodePtr theStudent, Handle *buffer, short *refNum, long *size, long *counter, short *recordLength, Boolean flush){	if((*counter) >= (*size))                   /* If at the end of the buffer, write out buffer to disk */	{		*counter = 0;		WriteOutBuffer(buffer, refNum, size);	}		HLock(*buffer);	memcpy(**buffer + (*counter), theStudent, *recordLength);    /* Write theStudent to buffer */	HUnlock(*buffer);		(*counter) += (long) (*recordLength);		if(flush)	{		WriteOutBuffer(buffer,refNum, counter);	}		return false;}	/*******************************************************************		void CreateIndex(void)--------------------------------------------------------------------SYNOPSIS: This routine creates an index of the User Database file.		  It is indexed on the student number field. It is recursive.          CALLED BY: ReadFromBuffer() "files.c"PASS: nothingRETURN: nothingREVISION HISTORY:	Name				Date		Description	----				----		-----------	Jeremy C Norberg	9/01/93		Initial version*********************************************************************/void CreateIndex(void){	short	inputRefNum, outputRefNum;	FSSpec	inputFSSpec, outputFSSpec;	long	inputCounter, outputCounter = 0;	long	inputSize, outputSize;	long 	indexNumber, tempIndexNumber = -1;		Handle	inputBuffer, outputBuffer;	userNode	theStudent, tempStudent;	Boolean	done = false;		/**********************************	  Figure out the size of the records being writen and read	**********************************/		inputSize = kRecordNumber * sizeof(userNode);	outputSize = kRecordNumber * (sizeof(long) * 2);		/**********************************	  Create buffers	**********************************/		inputBuffer = NewHandle(inputSize);	outputBuffer = NewHandle(outputSize);			/**********************************	  Open database file and create index file	**********************************/		if(FSMakeFSSpec(0,0,kUserDBFileName, &inputFSSpec))		DoError("\pError Open Database File.", true);		if(FSMakeFSSpec (0, 0, kUserDBIndexFileName, &outputFSSpec) != -43)	{		if(FSpDelete(&outputFSSpec))			DoError("\pError Deleting Index File.", true);		}		if(FSpCreate(&outputFSSpec, 'NORM', 'NMIX', (ScriptCode) -1))		DoError("\pError Creating Index File.", true);			if(FSpOpenDF(&outputFSSpec, fsCurPerm, &outputRefNum))		DoError("\pError Open Index File.", true);		if(FSpOpenDF(&inputFSSpec, fsCurPerm, &inputRefNum))		DoError("\pError Openning Database File.", true);		theStudent.studentNumber = 0;		/**********************************	  Loop through all records	  	  This block will create the index and also delete duplicates. Of the Duplicates,	  it choose the one with the highest priority to write to the index file. 	  	  e.g.	  	    S #		priority	 * 9999			1	   9999			2	   9999			1	 * 1001			1	 * 2001			2	 	 * writen to index	  	**********************************/		while(!done)	{		if(FSRead(inputRefNum, &inputSize, *inputBuffer) == -39)    /* at the end of the file */		{			if(inputSize == 0)                                      /* read anything? if not where done */			{				done = true;			}		}				for(inputCounter = 0; inputCounter < inputSize; inputCounter += sizeof(userNode))		{ 			tempStudent = ((userNodePtr) (*inputBuffer + inputCounter))[0];			tempIndexNumber ++;						if(theStudent.studentNumber == 0)			{				theStudent = tempStudent;				indexNumber = tempIndexNumber;			}			else if(tempStudent.studentNumber == theStudent.studentNumber)			{				if(theStudent.priority > tempStudent.priority)				{					theStudent = tempStudent;					indexNumber = tempIndexNumber;				}			}			else			{				HLock(outputBuffer);				memcpy(*outputBuffer + (outputCounter), &theStudent, sizeof(long));				outputCounter += sizeof(long);				memcpy(*outputBuffer + (outputCounter), &indexNumber, sizeof(long));				outputCounter += sizeof(long);								theStudent = tempStudent;				indexNumber = tempIndexNumber;								if(outputCounter >= outputSize)				{					FSWrite(outputRefNum, &outputSize, *outputBuffer);					outputCounter = 0;				}								HUnlock(outputBuffer);			}		}	}		HLock(outputBuffer);	memcpy(*outputBuffer + (outputCounter), &theStudent, sizeof(long));	outputCounter += sizeof(long);	memcpy(*outputBuffer + (outputCounter), &indexNumber, sizeof(long));	outputCounter += sizeof(long);		FSWrite(outputRefNum, &outputCounter, *outputBuffer);	HUnlock(outputBuffer);		FSClose(outputRefNum);	FSClose(inputRefNum);		FlushVol(nil, 0);		DisposHandle(outputBuffer);	DisposHandle(inputBuffer);}/*******************************************************************		char *CreateTempFileName(void)--------------------------------------------------------------------SYNOPSIS: Returns a unique filename based on the serial value of           the date.          CALLED BY: PASS: nothingRETURN: char *    : the file nameREVISION HISTORY:	Name				Date		Description	----				----		-----------	Jeremy C Norberg	6/24/94		Initial version*********************************************************************/void CreateTempFileName(Str255 tempFileName){	unsigned long 	fileNumber;	Str255			fileName = "Temp ", holder;			GetDateTime(&fileNumber);	NumToString(fileNumber, holder);	PtoCstr(holder);		strcat((char *) fileName, (char *) holder);     	CtoPstr((char *) fileName);		strncpy((char *) tempFileName, (char *) fileName, 64);		return;}