#include <Lists.h>#include <stdlib.h>#include "lab assistant.h"#include "Event.h"#include "Menu.h"#include "machine.h"#include "dialogEvents.h"#include "interface.h"#include <stdlib.h>#include <icons.h>#include "computerIcons.h"#include "database.h"#include "checkStatus.h"#include "user.h"#include "toolbar.h"#include "transferUser.h"#include "dialog.h"#include "mainMachineList.h"#include "waitList.h"#include "error.h"extern Boolean 	gDone;extern Rect		kScreenBBox;long			gLastWhen;Point			gLastWhere;/*------------------------------------------------------------------		void EventLoop(void)--------------------------------------------------------------------SYNOPSIS: Main Event loop for the applicationCALLED BY: main() "Norm.c"PASS: Nothing	RETURN: NothingDESTROYED: NothingREVISION HISTORY:	Name				Date		Description	----				----		-----------	Jeremy C Norberg	9/01/93		Initial version--------------------------------------------------------------------*/void EventLoop(void){	EventRecord		theEvent;	DialogPtr		theDialog;	short			itemHit;	short 			machineNumber;	//winRefConRecHdl	refCon;	//WindowPtr		theWindow;	//Byte			windowID;			MenuHandle		theMenu;	WaitList		theWaitingList;	extern char 	gFeatureFlag;	winRefConRecHdl	refCon;		gDone = false;		while (gDone == false)	{		//theWaitingList.ReadListFromFile();		//theWindow = FrontWindow();		//refCon = (winRefConRecHdl) GetWRefCon(theWindow);		//HLock((Handle)refCon);		//windowID = (*refCon)->windowID;		//HUnlock((Handle)refCon);				//if( (windowID == kMainWindow) && (theWaitingList.IsThereAWaitList()) )		//{		//	theWaitingList.CheckInFromWaitList();		//}						//if (theWaitingList.IsThereAWaitList())		//{		//	theMenu = GetMenu(135);		//	EnableItem(theMenu, 0);					//}		//else		//{		//	theMenu = GetMenu(135);		//	DisableItem(theMenu, 0);		//}		//theWaitingList.~WaitList();			theDialog = FrontWindow();		refCon = (winRefConRecHdl) GetWRefCon(theDialog);		HLock((Handle)refCon);		if((*refCon)->windowID == kMainWindow)		{					if(BitTst(&gFeatureFlag, 5L))			{				theMenu = GetMenu(135);				EnableItem(theMenu, 0);			}			else			{				theMenu = GetMenu(135);				DisableItem(theMenu, 0);			}						if( (BitTst(&gFeatureFlag, kWaitingListCheck)) &&				(!BitTst(&gFeatureFlag, kTeachingFlag)) &&				(FindEmptyMachine(&machineNumber)) )			{				theWaitingList.ReadListFromFile();				theWaitingList.CheckInFromWaitList();			}										}		HUnlock((Handle)refCon);				if (WaitNextEvent(everyEvent, &theEvent, 20L, nil))			DoEvent(&theEvent);		else		{				if(IsDialogEvent(&theEvent))				DialogSelect(&theEvent, &theDialog, &itemHit);		}	}		ExitToShell();	}/*------------------------------------------------------------------		void DoEvent(EventRecord *eventPtr)--------------------------------------------------------------------SYNOPSIS: Parse out the event type to the proper routinesCALLED BY: EventLoop() "Event.c"PASS: EventRecord *	RETURN: NothingDESTROYED: NothingREVISION HISTORY:	Name				Date		Description	----				----		-----------	Jeremy C Norberg	9/01/93		Initial version------------------------------------------------------------------*/void DoEvent(EventRecord *theEvent){	char			theChar;	WindowPtr		theWindow;		if(IsDialogEvent(theEvent))	{			DoDialogEvent(theEvent);		return;	}		switch (theEvent->what)	{		case mouseDown:			HandleMouseDown(theEvent);			break;		case keyDown:		case autoKey:			theChar = theEvent->message & charCodeMask;			if ((theEvent->modifiers & cmdKey) != 0)				HandleMenuChoice(MenuKey(theChar));			break;		case updateEvt:			theWindow = (WindowPtr) theEvent->message;			BeginUpdate(theWindow);			DrawMainWindow(theWindow);			EndUpdate(theWindow);			break;	}}/*******************************************************************		void HandleMouseDown(EventRecord *eventPtr)--------------------------------------------------------------------SYNOPSIS: Handles if the event was the mouse button pressed,          figures out where it was pressed and parse to the correct          routines.CALLED BY: DoEvent() "Event.c"PASS: EventRecord *	RETURN: NothingDESTROYED: NothingREVISION HISTORY:	Name				Date		Description	----				----		-----------	Jeremy C Norberg	9/01/93		Initial version*********************************************************************/void HandleMouseDown(EventRecord *eventPtr){	WindowPtr			whichWindow, theDialog;	short				thePart;	long				menuChoice;	winRefConRecHdl		refCon;	unsigned char		windowID;		thePart = FindWindow(eventPtr->where, &whichWindow);		switch (thePart)        	{		case inMenuBar:                                     			menuChoice = MenuSelect(eventPtr->where);			HandleMenuChoice(menuChoice);			break;		case inSysWindow:			SystemClick(eventPtr,whichWindow);			break;		case inContent:			theDialog = FrontWindow();				refCon = (winRefConRecHdl) GetWRefCon(theDialog);				HLock((Handle) refCon);			windowID = (*refCon)->windowID;			HUnlock((Handle) refCon);						if((*refCon)->windowID > kBaseResID)				SysBeep(8);			else			{							GlobalToLocal(&eventPtr->where);				InContent(eventPtr->where, eventPtr);			}						break;		case inDrag:			theDialog = FrontWindow();						if(whichWindow != theDialog)			{				SysBeep(8);			}			else			{				DragWindow(whichWindow, eventPtr->where, &kScreenBBox);				}			break;	}}/*******************************************************************		void InContent(Point pointWhere, EventRecord *eventPtr)--------------------------------------------------------------------SYNOPSIS: Handles if the mouse button pressed was in the main window.CALLED BY: HandleMouseDown() "Event.c"PASS: EventRecord *	  Point	RETURN: NothingDESTROYED: NothingREVISION HISTORY:	Name				Date		Description	----				----		-----------	Jeremy C Norberg	9/01/93		Initial version*********************************************************************/void InContent(Point pointWhere, EventRecord *theEvent){	short				computerNumber, droppedComputerNumber, buttonNumber;	Point				mouseLocation, destPt;	Rect				dragRegionRect;	RgnHandle			theIconRgn;	long				dropLocation;	grayRgnRefCon 		theRefCon;	computerRecPtr		theComputer, droppedComputer;		long				hDist, vDist; 	dialogRecordHdl		dialogRecord;	ListHandle			theList;		Cell				theCell;	char   				identification[31];	short				legnth;	long				computerNum;	long 				computerArrayNum;	char 				*endPtr;	Boolean				clicks;					theList = GetListHandle();			clicks = LClick(pointWhere, theEvent->modifiers, theList);		if (clicks)			 	{        									//MakeList();		//theList = GetListHandle();			//SetPt(&theCell,0,0);		theCell = LLastClick(theList);		LGetSelect(1,&theCell, theList);		legnth = sizeof(identification);		LGetCell(identification, &legnth, theCell, theList);					identification[3] = '\0';				//CtoPString(identification);		//idPtr = (Str255)identification;		//StringToNum((Str255)identification, &computerNum);				computerNum = strtol(identification,&endPtr, 10);   			FindMachineNumber(computerNum, &computerArrayNum);				LockMachineRecordHdl();		theComputer = GetMachineRecord(computerArrayNum);				if( (!BitTst(&theComputer->status, kComputerWorking)) ||				(BitTst(&theComputer->status, kTeachingSet)) ||				(!BitTst(&theComputer->status, kComputerInUse)) )		{			SysBeep(0);			UnLockMachineRecordHdl();			return;		}		UnLockMachineRecordHdl();				//computerArrayNum		dialogRecord = CreateDialogRec(CheckMachineStatus, kEventCheckMachineStatus,  computerArrayNum, ok, nil);				//dialogRecord = (dialogRecordHdl) NewHandle(sizeof(dialogRec));		//HLock((Handle) dialogRecord);		//(*dialogRecord)->theRecord = (long) computerArrayNum;		//(*dialogRecord)->theEvent = kEventCheckMachineStatus;		//(*dialogRecord)->callBack = CheckMachineStatus;		//HUnlock((Handle) dialogRecord);				//LSetSelect(FALSE, theCell, theList);							UserInfoBoxSetup(dialogRecord);		//checked for lock up bug				LGetSelect(1,&theCell, theList);		LSetSelect(FALSE, theCell, theList);		LUpdate((*theList)->port->visRgn, theList);					return;		//SysBeep(0);			}					      								if(PointInComputer(pointWhere, &computerNumber))	{		if (((theEvent->when - gLastWhen) < GetDblTime())         /* Was it double clicked? */			 && (abs(theEvent->where.h - gLastWhere.h) < 5)			 && (abs(theEvent->where.v - gLastWhere.v) < 5))		{			LockMachineRecordHdl();			theComputer = GetMachineRecord(computerNumber);			// if theres no one at the computer, but your still trying to find out about the user...						if ( !BitTst(&theComputer->status, kComputerInUse))			{				NewAlert("\pThere is no one using that computer",false, ok, 2);				UnLockMachineRecordHdl();				return;			}			UnLockMachineRecordHdl();						dialogRecord = (dialogRecordHdl) NewHandle(sizeof(dialogRec));						HLock((Handle) dialogRecord);			(*dialogRecord)->theRecord = (long) computerNumber;			(*dialogRecord)->theEvent = kEventCheckMachineStatus;			(*dialogRecord)->callBack = CheckMachineStatus;			HUnlock((Handle) dialogRecord);													UserInfoBoxSetup(dialogRecord);						return;		}				gLastWhen = theEvent->when;								/* Set time of first click */		gLastWhere = theEvent->where;                           // Set where the mouse was clicked				LockMachineRecordHdl();		theComputer = GetMachineRecord(computerNumber);				if(!BitTst(&theComputer->status, kSelected))		{				DeselectIcons();			SelectIcon(computerNumber);		}		}	else	{			if(PointInToolbar(pointWhere, buttonNumber))			HandleToolBar(buttonNumber);		// Check for Toolbar		DeselectIcons();		UnLockMachineRecordHdl();		return;	}		while(StillDown())	{		GetMouse(&mouseLocation);				dragRegionRect.left = mouseLocation.h - 5;                   		dragRegionRect.top = mouseLocation.v - 5;		dragRegionRect.right = mouseLocation.h + 5; 		dragRegionRect.bottom = mouseLocation.v + 5;				if(!PtInRect(theEvent->where, &dragRegionRect))               /* Is mouse movement inside of drag boundries */		{			theIconRgn = NewRgn();						IconIDToRgn(theIconRgn, &theComputer->computerRect, 0, kMachineWorkingIcon);						dropLocation = MyDragGrayRgn(theIconRgn, pointWhere, (myDragGrayRgnProcPtr) WhileDraging, (long) &theRefCon); 						DisposeRgn(theIconRgn);						hDist = LoWord(dropLocation);                    /* Find point where icon was dropped */			vDist = HiWord(dropLocation);							destPt.v = (short) vDist + pointWhere.v;			destPt.h = (short) hDist + pointWhere.h;						if(PointInComputer(destPt, &droppedComputerNumber))			{				if(droppedComputerNumber == computerNumber)					return;								LockMachineRecordHdl();				droppedComputer = GetMachineRecord(droppedComputerNumber);					BitClr(&droppedComputer->status, kSelected);				DrawMachineIcon(droppedComputer);				UnLockMachineRecordHdl();				DoTransfer(computerNumber, droppedComputerNumber);				}			else if(PointInToolbar(destPt, buttonNumber))				HandleToolBar(buttonNumber, computerNumber);		}	}			UnLockMachineRecordHdl();}/*******************************************************************		void Quit(void)--------------------------------------------------------------------SYNOPSIS: Gracefully quits the applicationCALLED BY: PASS: nothing.RETURN: nothingREVISION HISTORY:	Name				Date		Description	----				----		-----------	Jeremy C Norberg	9/01/93		Initial version*********************************************************************/void Quit(void){	gDone = true;	}