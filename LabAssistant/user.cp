#include <ToolUtils.h>#include <Resources.h>#include <string.h>#include <stdio.h>#include <stdlib.h>#include <icons.h>#include "lab assistant.h"#include "user.h"#include "machine.h"#include "database.h"#include "interface.h"#include "Menu.h"#include "listBox.h"#include "userRecord.h"#include "computerIcons.h"#include "error.h"#include "waitList.h"#include "checkIn.h"void UserEnterBoxSetup(dialogRecordHdl dialogRecord){	GrafPtr			oldPort;	DialogPtr		theDialog;	winRefConRecHdl	refCon;	short			itemType;	Handle			itemHandle;	Rect			itemRect;	RGBColor		theColor;			DisableMenus(true);	GetPort(&oldPort);		theDialog = GetNewDialog(kUserEnterBoxID, nil, (WindowPtr)-1L);		SetPort(theDialog);		refCon = (winRefConRecHdl) NewHandle(sizeof(winRefConRec));        // Create Ptr to refCon record		HLock((Handle) refCon);	(*refCon)->windowID = kUserEnterBoxID;                          // Assign the WindowID	(*refCon)->dialogRecord = dialogRecord;	(*refCon)->oldPort = (long) oldPort;                                 // Assign the misc field to the oldPort. This required when closeing dialog box	HUnlock((Handle) refCon);		SetWRefCon(theDialog, (long) refCon);          // Set the WindowRefCon of the UserEnterBox												   // dialog 													GetDItem(theDialog, ok, &itemType, &itemHandle, &itemRect);	HiliteControl((ControlHandle) itemHandle, 255);		GetDItem(theDialog, 7, &itemType, &itemHandle, &itemRect);	SetDItem(theDialog, 7, itemType, (Handle) DrawOKOutline, &itemRect);		ShowWindow(theDialog);		theColor.red = 65535;	theColor.green = 65535;	theColor.blue = 65535;			RGBBackColor(&theColor);		GetDItem(theDialog, 4, &itemType, &itemHandle, &itemRect);	InsetRect(&itemRect, -4, -4);	Add3dRaised(&itemRect, true, true, false);	}void UserEnterBoxEvent(EventRecord *theEvent){	WindowPtr			theDialog, oldPort;	winRefConRecHdl		refCon;	Handle				idNumberHandle, okButtonHandle, cancelButtonHandle;	short				itemType, itemHit = 0;	Rect				itemRect;   	Str255				itemString;	char				theKey;	char				stringLen;	Boolean				done = false;	long				studentNumber;	dialogRecordHdl		dialogRecord;	dialogProcPtr		callBack;	theDialog = FrontWindow();		refCon = (winRefConRecHdl) GetWRefCon(theDialog);        // Get the Window Ref Record from the Windows Ref Con	HLock((Handle) refCon);	oldPort = (WindowPtr) (*refCon)->oldPort;	dialogRecord = (dialogRecordHdl) (*refCon)->dialogRecord;	HUnlock((Handle) refCon);		HLock((Handle) dialogRecord);	callBack = (*dialogRecord)->callBack;	HUnlock((Handle) dialogRecord);		GetDItem(theDialog, 4, &itemType, &idNumberHandle, &itemRect);	GetDItem(theDialog,ok, &itemType, &okButtonHandle, &itemRect);	GetDItem(theDialog, 2, &itemType, &cancelButtonHandle, &itemRect);			switch(theEvent->what)          							 //Handle Keys before passing off to Dialog Select	{		case keyDown:		case autoKey:			theKey = theEvent->message & charCodeMask;       			 // Mask out the char from the event message						if(theEvent->modifiers & cmdKey)			{								done = HandleCommandKeys(theKey, theDialog);			}			else			{				switch (theKey)				{					case '\r':			// Return					case '\003':		// Enter						itemHit = ok;						done = true;						break;					case '\010':		// BackSpace						break;					case '\033':		// ESC						itemHit = cancel;						done = true;						break;					case '\034':		// Left arrow					case '\035':		// Right arrow						break;					default:			// Everything else falls through to be dealt with						GetIText(idNumberHandle, itemString);							stringLen = (char) itemString[0];																		if((stringLen > 6) || (theKey < '0' || theKey > '9'))						{								SysBeep(0); // If it is not a number or the len is > 6, beep!							return;						}																break;				}			}		}			if(!done)	{			if(!DialogSelect(theEvent, (DialogPtr *) &theDialog, &itemHit))			return;                // Nothing to Handle, just return.	}                                	GetIText(idNumberHandle, itemString);		PtoCString(itemString);	if (!strcmp((char *)itemString,"9434585"))	{		NewAlert("\pWhat Is Your Bidding, Master?", false, ok, 2);	}	CtoPString((char *)itemString);			stringLen = (char) itemString[0];		if(stringLen == 7)		HiliteControl((ControlHandle) okButtonHandle, 0);	else		HiliteControl((ControlHandle) okButtonHandle, 255);		/*	if(stringLen < 2 )						{							SetDialogDefaultItem(theDialog, 2);						}						else						{							SetDialogDefaultItem(theDialog, ok);						}	*/		switch (itemHit)	{		case ok:			if(stringLen < 1)			{					break;			}			StringToNum(itemString, &studentNumber);						HLock((Handle) dialogRecord);			(*dialogRecord)->theRecord = studentNumber;				case cancel:			(*dialogRecord)->itemHit = itemHit;			HUnlock((Handle) dialogRecord);			DisposeDialog(theDialog);			DisposeHandle((Handle) refCon);			SetPort(oldPort);						callBack(dialogRecord);   //checkInCallBack			break;					case 3:									//case other:			 			(*dialogRecord)->itemHit = 3;			//HUnlock((Handle) dialogRecord);			//DisposeDialog(theDialog);			//DisposeHandle((Handle) refCon);			//SetPort(oldPort);						(*dialogRecord)->theEvent = kEventUserList;			(*dialogRecord)->theRecord = (long)CreateUserList();									DisposeDialog(theDialog);			DisposeHandle((Handle)refCon);			SetPort(oldPort);						ReadUserInfo((userNode *)(*dialogRecord)->theRecord);			HUnlock((Handle) dialogRecord);						ListBoxSetup(dialogRecord);						DeleteUserList((userNode *)(*dialogRecord)->theRecord);						//(*dialogRecord)->theRecord = 9434583;						//HUnlock((Handle) dialogRecord);			//DisposeDialog(theDialog);			//DisposeHandle((Handle) refCon);			//SetPort(oldPort);						//callBack(dialogRecord);			break;			}}void UserInfoBoxSetup(dialogRecordHdl dialogRecord){	GrafPtr			oldPort;	DialogPtr		theDialog;	winRefConRecHdl	refCon;	short			itemType;	Handle			itemHandle;	Rect			itemRect;	Str255			itemText;	Str255			instString, specInstString;	short			status;	computerRecPtr	theComputer;	Byte			dialogEvent;	long			machineArrayNumber;	CIconHandle		iconHdl;			GetPort(&oldPort);		theDialog = GetNewDialog(kUserInfoBoxID, nil, (WindowPtr)-1L);		SetPort(theDialog);					refCon = (winRefConRecHdl) NewHandle(sizeof(winRefConRec));        // Create Ptr to refCon record	iconHdl = (CIconHandle)NewHandle(sizeof(CIconHandle));		HLock((Handle) refCon);	(*refCon)->windowID = kUserInfoBoxID;                          // Assign the WindowID	(*refCon)->oldPort = (long) oldPort;                          // Assign the misc field to the oldPort. This required when closeing dialog box	(*refCon)->dialogRecord = dialogRecord;	HUnlock((Handle) refCon);				HLock((Handle) dialogRecord);	machineArrayNumber = (*dialogRecord)->theRecord;	dialogEvent = (*dialogRecord)->theEvent;		if(dialogEvent == kEventCheckUserStatus)		theComputer = (computerRecPtr) (*dialogRecord)->misc;		else		theComputer = GetMachineRecord(machineArrayNumber);			HUnlock((Handle) dialogRecord);	LockMachineRecordHdl();		// if theres no one at the computer, but your still trying to find out about the user...	//if ( (dialogEvent == kEventCheckMachineStatus) && !BitTst(&theComputer->status, kComputerInUse))	//{	//	NewAlert("\pThere is no one using that computer",false, ok, 2);	//	DisposeHandle((Handle)refCon);	//	DisposeCIcon(iconHdl);	//	SetPort(oldPort);	//	return;	//}				ShowWindow(theDialog);		SetWRefCon(theDialog, (long) refCon);                          // Set the WindowRefCon			SetWTitle(theDialog,"\pUser Information");		GetDItem(theDialog, 21, &itemType, &itemHandle, &itemRect);	SetDItem(theDialog, 21, itemType, (Handle) DrawOKOutline, &itemRect);		GetDItem(theDialog, 3, &itemType, &itemHandle, &itemRect);	NumToString(theComputer->userInfo.studentNumber, itemText);	SetIText(itemHandle, itemText);		GetDItem(theDialog, 4, &itemType, &itemHandle, &itemRect);	strncpy((char *) itemText, theComputer->userInfo.name, sizeof(theComputer->userInfo.name));	itemText[29] = 0;	CtoPstr((char *) itemText);	SetIText(itemHandle, itemText);		GetDItem(theDialog, 5, &itemType, &itemHandle, &itemRect);	NumToString((long)theComputer->userInfo.priority, itemText);	SetIText(itemHandle, itemText);		GetDItem(theDialog, 6, &itemType, &itemHandle, &itemRect);	if(theComputer->userInfo.gender == 'M')		SetIText(itemHandle, "\pMale");	else if(theComputer->userInfo.gender == 'F')		SetIText(itemHandle, "\pFemale");	else		SetIText(itemHandle, "\pUnknown");		GetDItem(theDialog, 7, &itemType, &itemHandle, &itemRect);	status = CheckforRestriction(&theComputer->userInfo);				switch(status)	{		case kNoRestricition:			sprintf((char *) itemText, "No Restrictions");			sprintf((char *) specInstString, "");			break;		case kFullRestriction:			sprintf((char *) itemText, "Full Restriction");			sprintf((char *) specInstString, "¥ This user is Restricted, and may NOT use the lab./r");			break;		case kPartialRestriction:			sprintf((char *) itemText, "Partial Restriction");			sprintf((char *) specInstString, "¥ This user is restricted and should see the manager within 3 days./r");			break;		case kTempUser:			sprintf((char *) itemText, "No Restrictions");			sprintf((char *) specInstString, "¥ This user has temporary access.\r");			break;	}	CtoPstr((char *) itemText);	CtoPstr((char *) specInstString);	SetIText(itemHandle, itemText);		GetDItem(theDialog, 8, &itemType, &itemHandle, &itemRect);	IUTimeString(theComputer->timeOn, false, itemText);	SetIText(itemHandle, itemText);	GetDItem(theDialog, 9, &itemType, &itemHandle, &itemRect);	switch(dialogEvent)	{		case kEventCheckIn:			sprintf((char *) instString, "Give the User the CPU Card and clip the users ID under the Consultant CPU Card.");			break;		case kEventCheckUserStatus:		case kEventCheckMachineStatus:			HideDItem(theDialog, cancel);			HideDItem(theDialog, 22);				//22 = emergency override			sprintf((char *) instString, "");			break;		case kEventCheckOut:			sprintf((char *) instString, "¥ Check the ID against the information above.\r¥ Ask user if they did a Special Restart.\r¥ Return the ID to the user and ask if it is theirs.\r¥ Clip the CPU card to the consultant card.");			break;	}	CtoPstr((char *) instString);	InsetRect(&itemRect, -2, -2);	Add3dRaised(&itemRect, true, false, false);	SetIText(itemHandle, instString);		GetDItem(theDialog, 10, &itemType, &itemHandle, &itemRect);	SetIText(itemHandle, specInstString);	InsetRect(&itemRect, -2, -2);	Add3dRaised(&itemRect, true, false, false);			TextFont(geneva);	TextSize(18);	TextMode(kDefaultTextMode);		HLock((Handle) iconHdl);	GetDItem(theDialog, 11, &itemType, &itemHandle, &itemRect);	iconHdl = GetCIcon(140);	PlotCIconHandle(&itemRect, atNone, ttNone, iconHdl);	//PlotCIconHandle(&itemRect, atNone, ttNone, GetCIcon(140));	DisposCIcon(iconHdl);	HUnlock((Handle) iconHdl);				NumToString(theComputer->number, itemText);	MoveTo(itemRect.left+5,itemRect.top+23);	DrawString(itemText);			TextFont(9842);	TextSize(kDefaultTextSize);	TextMode(kDefaultTextMode);		//DisposeHandle((Handle)iconHdl);	//DisposCIcon(iconHdl);	//DisposePtr((Ptr) theComputer);				UnLockMachineRecordHdl();}void UserInfoBoxEvent(EventRecord *theEvent){	WindowPtr			theDialog, oldPort;	winRefConRecHdl		refCon;	Handle				idNumberHandle, okButtonHandle;	short				itemType, itemHit = 0;	Rect				itemRect;	char				theKey;	Boolean				done = false;	dialogProcPtr		callBack;	dialogRecordHdl		dialogRecord;	Handle				itemHandle;		Str255				itemString;	long				theNumber;	userNode			theUser;		theDialog = FrontWindow();				refCon = (winRefConRecHdl) GetWRefCon(theDialog);        // Get the Window Ref Record from the Windows Ref Con	HLock((Handle) refCon);	oldPort = (WindowPtr) (*refCon)->oldPort;	dialogRecord = (dialogRecordHdl) (*refCon)->dialogRecord;	HUnlock((Handle) refCon);		HLock((Handle) dialogRecord);	callBack = (*dialogRecord)->callBack;	HUnlock((Handle) dialogRecord);					GetDItem(theDialog, 4, &itemType, &idNumberHandle, &itemRect);	GetDItem(theDialog, ok, &itemType, &okButtonHandle, &itemRect);			switch(theEvent->what)          							 //Handle Keys before passing off to Dialog Select	{		case keyDown:		case autoKey:			theKey = theEvent->message & charCodeMask;       			 // Mask out the char from the event message						switch (theKey)			{				case '\r':			// Return				case '\003':		// Enter					itemHit = ok;					done = true;					break;				case '\033':		// ESC					itemHit = cancel;					done = true;					break;			}		}			if(!done)	{			if(!DialogSelect(theEvent, (DialogPtr *) &theDialog, &itemHit))			return;                // Nothing to Handle, just return.	}                                		WaitList	theWaitingList;	switch (itemHit)	{		case 22:									//22 is emrgencyOverride						GetDItem(theDialog, 3, &itemType, &itemHandle, &itemRect);			GetIText(itemHandle, itemString);			StringToNum(itemString, &theNumber);			Search(&theNumber, &theUser);						DisposeDialog(theDialog);			DisposeHandle((Handle) refCon);			//DisposeHandle(itemHandle);			SetPort(oldPort);						theWaitingList.PutAtFrontOfList(theUser);			HandleCheckIn();			return;			break;							case ok:			case cancel:			GetDItem(theDialog, 11, &itemType, &itemHandle, &itemRect);			DisposeDialog(theDialog);			DisposeHandle((Handle) refCon);			//DisposeHandle(itemHandle);			SetPort(oldPort);						HLock((Handle) dialogRecord);			(*dialogRecord)->itemHit = itemHit;			HUnlock((Handle) dialogRecord);						callBack(dialogRecord);			//DisposeHandle((Handle)dialogRecord);									break;	}																// If the user enter box is still	theDialog = FrontWindow();									// up, get rid of it	refCon = (winRefConRecHdl) GetWRefCon(theDialog);				if ((*refCon)->windowID == kUserEnterBoxID)	{		oldPort = (WindowPtr)(*refCon)->oldPort;		DisposeDialog(theDialog);		DisposeHandle((Handle)refCon);		SetPort(oldPort);	}		if ((*refCon)->windowID == kUserInfoBoxID)		return;			DisableMenus(false);}