#include <string.h>#include <stdlib.h>#include <stdio.h>#include "Lab Assistant.h"#include "bumpUser.h"#include "mainMachineList.h"#include "database.h"#include "error.h"#include "checkIn.h"#include "checkOut.h"#include "event.h"#include "user.h"#include "dialog.h"#include "interface.h"#include "waitList.h"Boolean		gLocDone;/*******************************************************************		int BumpCompare(const void *n1, const void *n2)--------------------------------------------------------------------SYNOPSIS: Call back routine for the qsort routine.CALLED BY: PASS: const void *n1     	 : button pressed	  const void *n2         : where it was pressedRETURN: int				 	 : see qsort documentationREVISION HISTORY:	Name				Date		Description	----				----		-----------	Jeremy C Norberg	9/01/93		Initial version*********************************************************************/int BumpCompare(const void *n1, const void *n2){	computerRecord s1,s2;		/* transfer n1 and n2 to a computerRecord */		memcpy(&s1, n1, sizeof(s1));	memcpy(&s2, n2, sizeof(s2));		/* if computer s1 is not in use, set priority and time on to 0 */		if(!BitTst(&s1.status, kComputerInUse) || BitTst(&s1.status, kTeachingSet))	{		s1.userInfo.priority = 0;		s1.timeOn = 0;	}		/* if computer s2 is not in use, set priority and time on to 0 */		if(!BitTst(&s2.status, kComputerInUse) || BitTst(&s2.status, kTeachingSet))	{		s2.userInfo.priority = 0;		s2.timeOn = 0;	}		/* see which s1 or s2 has the highest priority */		if(s1.userInfo.priority > s2.userInfo.priority)		return -1;	if(s1.userInfo.priority < s2.userInfo.priority)		return 1;	else		/* if the same priority see which one has lower timeOn */		{			if(s1.timeOn > s2.timeOn)			return 1;		else if(s1.timeOn < s2.timeOn)			return -1;		else			return 0;	}}    Boolean Bump(userNodePtr theUser, dialogRecordHdl dialogRecord){	ListHandle			theList;	//ListHandle			bumpSortedList;	computerRecord		sortedList[100];	computerRecPtr		theComputer;	//computerRecPtr		computerCounter;	short				counter;	long				numberofMachines;	//dialogRecordHdl		dialogRecord;	short				computerArrayNumber;	short				itemType;	Handle				itemHandle;	Rect				itemRect;	Str255				itemText;		GrafPtr				oldPort;	DialogPtr			theDialog;	winRefConRecHdl		refCon;	Str255				computerNumberString;	short				status;	char				warningString[200];		//*************************************************************************	theList = GetListHandle();		dialogRecord = (dialogRecordHdl) NewHandle(sizeof(dialogRec));		LDoDraw(false, theList);      // turn list drawing off for speed increase 		numberofMachines = GetNumberofMachines();		LockMachineRecordHdl();	for(counter = 0; counter < numberofMachines; counter ++) // make a copy of the gComputerRecord to sort 	{		theComputer = GetMachineRecord(counter);		memcpy(&sortedList[counter], theComputer, sizeof(computerRecord));	}	UnLockMachineRecordHdl();		// sort the list 		qsort(sortedList, numberofMachines, sizeof(sortedList[0]), BumpCompare);		if (sortedList[0].userInfo.priority <= theUser->priority)	{		//NewAlert("\pThe user doesn't have high enough priorety to bump anyone.",		//				false, ok, 2);		strcpy(warningString, "The user doesn't have high enough priorety to bump anyone. ");								if (theUser->priority == 1)		{						WaitList	theWaitingList;						if (theWaitingList.WaitListAdd(*theUser))			{				//NewAlert("\pThe user will be put on the waiting list.  Tell them to wait outside",				//	false, ok, 2);								strcat(warningString, "The user will be put on the waiting list.  Tell them to wait outside ");							}			else 			{				//NewAlert("\pThe user is already on the waiting list.  Tell them to go sit there ragady ass outside and wait!",				//	false, ok, 2);				strcat(warningString, "The user is already on the waiting list.  Tell them to go sit there ragady ass outside and wait! ");							}						}				NewAlert(CtoPString(warningString), false, ok, 2);						return(0);	}		if (theUser->priority < sortedList[0].userInfo.priority)	{								LockMachineRecordHdl();		for(counter = 0; counter < numberofMachines; counter ++)		{			theComputer = GetMachineRecord(counter);			if (theComputer->number == sortedList[0].number)			{				computerArrayNumber = counter;				break;			}		}		UnLockMachineRecordHdl();				GetPort(&oldPort);				theDialog = GetNewDialog(kBumpUserBoxID, nil, (WindowPtr)-1L);		refCon = (winRefConRecHdl) NewHandle(sizeof(winRefConRec));				SetPort(theDialog);		ShowWindow(theDialog);										HLock((Handle)refCon);		(*refCon)->windowID = kBumpUserBoxID;		(*refCon)->oldPort = (long) oldPort;		(*refCon)->dialogRecord = dialogRecord;		HUnlock((Handle)refCon);					//dialogRec->theRec has the user ID				SetWRefCon(theDialog, (long)refCon);				theComputer = &sortedList[0];				// set up the bump box************************************************************				TextFont(9840);		TextSize(10);				NumToString(sortedList[0].number,computerNumberString);		ParamText(computerNumberString, computerNumberString, kEmptyString, kEmptyString);				GetDItem(theDialog, 31, &itemType, &itemHandle, &itemRect);			//new user box		InsetRect(&itemRect, -2, -2);		Add3dRaised(&itemRect, true, false, false);				GetDItem(theDialog, 32, &itemType, &itemHandle, &itemRect);			//current user box		InsetRect(&itemRect, -2, -2);		Add3dRaised(&itemRect, true, false, false);				GetDItem(theDialog, 37, &itemType, &itemHandle, &itemRect);			//instructions box		InsetRect(&itemRect, -2, -2);		Add3dRaised(&itemRect, true, false, false);						GetDItem(theDialog, 8, &itemType, &itemHandle, &itemRect);			//student number		NumToString(theUser->studentNumber, itemText);		InsetRect(&itemRect, -2, -2);		Add3dRaised(&itemRect, true, false, false);		SetIText(itemHandle, itemText);				GetDItem(theDialog, 9, &itemType, &itemHandle, &itemRect);			//name		InsetRect(&itemRect, -2, -2);		Add3dRaised(&itemRect, true, false, false);		strncpy((char *)itemText, theUser->name, sizeof(theUser->name));		itemText[29] = 0;		CtoPstr((char *) itemText);		SetIText(itemHandle, itemText);				GetDItem(theDialog, 12, &itemType, &itemHandle, &itemRect);			//gender		if(theUser->gender == 'M')			SetIText(itemHandle, "\pMale");		else if(theUser->gender == 'F')			SetIText(itemHandle, "\pFemale");		else			SetIText(itemHandle, "\pUnknown");		InsetRect(&itemRect, -2, -2);		Add3dRaised(&itemRect, true, false, false);				GetDItem(theDialog, 10, &itemType, &itemHandle, &itemRect);			//priority		NumToString((long)theUser->priority, itemText);		InsetRect(&itemRect, -2, -2);		Add3dRaised(&itemRect, true, false, false);		SetIText(itemHandle, itemText);				GetDItem(theDialog, 11, &itemType, &itemHandle, &itemRect);			//status		status = CheckforRestriction(theUser);				switch(status)		{			case kNoRestricition:				sprintf((char *) itemText, "No Restrictions");				break;			case kFullRestriction:				sprintf((char *) itemText, "Full Restriction");				break;			case kPartialRestriction:				sprintf((char *) itemText, "Partial Restriction");				break;			case kTempUser:				sprintf((char *) itemText, "No Restrictions");				break;		}		CtoPstr((char *) itemText);														InsetRect(&itemRect, -2, -2);		Add3dRaised(&itemRect, true, false, false);		SetIText(itemHandle, itemText);				GetDItem(theDialog, 13, &itemType, &itemHandle, &itemRect);			//time in		InsetRect(&itemRect, -2, -2);		Add3dRaised(&itemRect, true, false, false);								// bumped user info---------------------------------------				GetDItem(theDialog, 21, &itemType, &itemHandle, &itemRect);			//student ID		NumToString(theComputer->userInfo.studentNumber, itemText);		InsetRect(&itemRect, -2, -2);		Add3dRaised(&itemRect, true, false, false);		SetIText(itemHandle, itemText);				GetDItem(theDialog, 22, &itemType, &itemHandle, &itemRect);			//name		strncpy((char *)itemText, theComputer->userInfo.name, sizeof(theComputer->userInfo.name));		itemText[29] = 0;		CtoPstr((char *) itemText);		SetIText(itemHandle, itemText);		InsetRect(&itemRect, -2, -2);		Add3dRaised(&itemRect, true, false, false);				GetDItem(theDialog, 25, &itemType, &itemHandle, &itemRect);			//gender		if(theComputer->userInfo.gender == 'M')			SetIText(itemHandle, "\pMale");		else if(theComputer->userInfo.gender == 'F')			SetIText(itemHandle, "\pFemale");		else			SetIText(itemHandle, "\pUnknown");		InsetRect(&itemRect, -2, -2);		Add3dRaised(&itemRect, true, false, false);				GetDItem(theDialog, 23, &itemType, &itemHandle, &itemRect);			//priority		NumToString((long)theComputer->userInfo.priority, itemText);		InsetRect(&itemRect, -2, -2);		Add3dRaised(&itemRect, true, false, false);		SetIText(itemHandle, itemText);				GetDItem(theDialog, 24, &itemType, &itemHandle, &itemRect);			//status		status = CheckforRestriction(&theComputer->userInfo);				switch(status)		{			case kNoRestricition:				sprintf((char *) itemText, "No Restrictions");				break;			case kFullRestriction:				sprintf((char *) itemText, "Full Restriction");				break;			case kPartialRestriction:				sprintf((char *) itemText, "Partial Restriction");				break;			case kTempUser:				sprintf((char *) itemText, "No Restrictions");				break;		}		CtoPstr((char *) itemText);		SetIText(itemHandle, itemText);		InsetRect(&itemRect, -2, -2);		Add3dRaised(&itemRect, true, false, false);				GetDItem(theDialog, 26, &itemType, &itemHandle, &itemRect);			//time out		InsetRect(&itemRect, -2, -2);		Add3dRaised(&itemRect, true, false, false);						}	HLock((Handle)dialogRecord);	(*dialogRecord)->theRecord = counter;	(*dialogRecord)->misc =theUser->studentNumber;	HUnlock((Handle)dialogRecord);		HLock((Handle)refCon);	(*refCon)->dialogRecord = dialogRecord;	HUnlock((Handle)refCon);		SetWRefCon(theDialog,(long)refCon);	return (0);	}			void BumpUserBoxEvent(EventRecord *theEvent){	WindowPtr			theDialog, oldPort;	winRefConRecHdl		refCon;	short				itemHit = 0;	char				theKey;	Boolean				done = false;	dialogRecordHdl		dialogRecord;	long 				counter, idNum;	computerRecPtr		theComputer;	userNode			theUser;		theDialog = FrontWindow();		refCon = (winRefConRecHdl) GetWRefCon(theDialog);	HLock((Handle) refCon);		oldPort = (WindowPtr) (*refCon)->oldPort;	dialogRecord = (dialogRecordHdl) (*refCon)->dialogRecord;	HLock((Handle)dialogRecord);	HUnlock((Handle) refCon);		counter = (*dialogRecord)->theRecord;	idNum = (*dialogRecord)->misc;		HUnlock((Handle)dialogRecord);	Search(&idNum, &theUser);			switch(theEvent->what)          							 //Handle Keys before passing off to Dialog Select	{		case keyDown:		case autoKey:			theKey = theEvent->message & charCodeMask;       			 // Mask out the char from the event message						switch (theKey)			{				case '\r':			// Return				case '\003':		// Enter					itemHit = ok;					done = true;					break;				case '\033':		// ESC					itemHit = cancel;					done = true;					break;			}		}		if(!done)	{			if(!DialogSelect(theEvent, (DialogPtr *) &theDialog, &itemHit))			return;                // Nothing to Handle, just return.	}		switch (itemHit)	{		case ok:			LockMachineRecordHdl();			theComputer = GetMachineRecord(counter);			UnLockMachineRecordHdl();			HLock((Handle)dialogRecord);			(*dialogRecord)->itemHit = ok;			HUnlock((Handle)dialogRecord);			CheckOutUser(dialogRecord);						memcpy(&theComputer->userInfo, &theUser, sizeof(userNode));			HLock((Handle)dialogRecord);			dialogRecord = (dialogRecordHdl) (*refCon)->dialogRecord;			(*dialogRecord)->itemHit = ok;			(*dialogRecord)->theRecord = counter;			HUnlock((Handle)dialogRecord);			CheckInUser(dialogRecord);						case cancel:			DisposeDialog(theDialog);			DisposeHandle((Handle) refCon);			SetPort(oldPort);	}}																			//place holder