#include "lab assistant.h"#include "userRecord.h"#include "Norm_Files.h"#include <string.h>#include <stdio.h>#include "error.h"//userNode * CreateUserList(void)userNodePtr  CreateUserList(void){	//userNode *endNode, *userHead;	userNodePtr	endNode, userHead;	userHead = (userNode *) NewPtr(sizeof(userNode));	//userHead = new userNode;	endNode = (userNode *) NewPtr(sizeof(userNode));	//endNode = new userNode;	userHead->next = endNode;		//userHead->next = NULL;	endNode->next = endNode;		return userHead;}void DeleteUserList(userNode *userHead){	userNode *nextUser;		nextUser = userHead->next;		while(userHead->next != userHead)	{		//nextUser = userHead->next;				DisposePtr((Ptr) userHead);		//delete userHead;				userHead = nextUser;		nextUser = nextUser->next;	}		DisposePtr((Ptr) userHead);}OSErr ReadUserInfo(userNode *userHead){	short			fRefNum;	FSSpec 			fileSpec;	OSErr			theError;	long			inOutCount;	userNode	theUser;		theError = FSMakeFSSpec(0, 0, kOtherUserDBFileName, &fileSpec);		if(theError)		return theError;		theError = FSpOpenDF(&fileSpec, fsCurPerm, &fRefNum);		if(theError)		return theError;		while(theError != -39)	{			inOutCount = sizeof(userNode);				theError = FSRead(fRefNum, &inOutCount, (Ptr) &theUser);				if(inOutCount == sizeof(userNode))			AddUserRecord(userHead, &theUser);	}		theError = FSClose(fRefNum);		return theError;}void AddUserRecord(userNode *userHead, userNode *theUser){	userNode		*newUser;	userNodePtr		userPtr, prevPtr;	if ( !CheckForOtherUser(userHead, theUser) )	{		newUser = (userNode *) NewPtr(sizeof(userNode));		userPtr = userHead->next;		prevPtr = userHead;				while (userPtr != userPtr->next)		{			if(strcmp(theUser->name,userPtr->name) < 0)				break;						userPtr = userPtr->next;			prevPtr = prevPtr->next;					}			memcpy(newUser, theUser, sizeof(userNode));				prevPtr->next = newUser;		newUser->next = userPtr;			//newUser->next = userHead->next;			//userHead->next = newUser;	}	else	{		NewAlert("\pThe User You Typed Already Exists.", false, ok, 2);	}}void DeleteUserRecord(userNode *userHead, userNode *theUser){	userNode	*deleteUser;		deleteUser = userHead;		while((deleteUser->next != theUser))	{		deleteUser = deleteUser->next;	}		deleteUser->next = theUser->next;		DisposePtr((Ptr) theUser);}void WriteUserInfo(userNode *userHead){	short		fRefNum;	FSSpec 		fileSpec, tempFileSpec;	OSErr		theError;	long		inOutCount;	userNode	*theUser;	Str255		tempFileName;		CreateTempFileName(tempFileName);	theError = FSMakeFSSpec(0, 0, kOtherUserDBFileName, &fileSpec);	if(theError)	{		theError = FSpCreate(&fileSpec, kCreatorType, 'NMDB', (ScriptCode) -1);	}		theError = FSMakeFSSpec(0, 0, tempFileName, &tempFileSpec);		if(theError)	{		theError = FSpCreate(&tempFileSpec, kCreatorType, 'TEMP', (ScriptCode) -1);	}		theError = FSpOpenDF(&tempFileSpec, fsCurPerm, &fRefNum);	theUser = userHead->next;		while(theUser->next != theUser)	{		inOutCount = sizeof(userNode);				theError = FSWrite(fRefNum, &inOutCount, theUser);				theUser = theUser->next;	}		theError = FSpExchangeFiles(&fileSpec, &tempFileSpec);	theError = FSClose(fRefNum);		theError = FSpDelete(&tempFileSpec);}Boolean SearchOtherUser(userNode *userHead, userNode *theUser, long studentNumber){		Boolean 	foundIt = false;	userNode	*searchUser;		searchUser = userHead->next;		while(searchUser != searchUser->next)	{		if(searchUser->studentNumber == studentNumber)		{			foundIt = true;			memcpy(theUser, searchUser, sizeof(userNode));			break;		}				searchUser = searchUser->next;	}		return foundIt;}	Boolean CheckForOtherUser(userNode *userHead, userNode *theUser){	Boolean 		foundIt = false;	userNode		*searchUser;	searchUser = userHead->next;	while(searchUser != searchUser->next)	{		if( (theUser->studentNumber == searchUser->studentNumber) ||				(!strcmp(searchUser->name, theUser->name) ) )		{			foundIt = true;			break;		}				searchUser = searchUser->next;		//check this for correctness	}	return foundIt;}void GetOtherUserID(char *searchName,dialogRecordHdl dialogRecord, userNode *theList){	long 		foundIt = false;			//foundIt returns the ID number or false if not found	userNode	*searchUser;		searchUser = theList->next;			HLock((Handle) dialogRecord);	while(searchUser != searchUser->next)	{		if (!strcmp(searchName, searchUser->name) )			// strcmp returns 0 for a match		{			(*dialogRecord)->theRecord = searchUser->studentNumber;			//foundIt = searchUser->studentNumber;			break;		}		searchUser = searchUser->next;	}	HUnlock((Handle) dialogRecord);		//return foundIt;}//void AlphabetizeList(userNode *userHead)//{//}	