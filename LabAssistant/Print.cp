#include <math.h>#include <Printing.h>#include "Lab Assistant.h"#include "interface.h"#include "Print.h"#include <stdio.h>#include <stdlib.h>#include <string.h>#include "mainMachineList.h"#include "database.h"extern Boolean			gDone, gComputerSelected, gIsHighlitedComputer, gIsButtonPressed;//extern computerRecord	gComputerRecord[100];//extern short			gNumberofComputers;extern short			gCurrentSelectComputer,gHighlitedComputer, gButtonPressed;extern CIconHandle		gComputerIconHandle, gComputerDownIconHandle, gUserIconHandle;extern CIconHandle		gCheckInIconHandle, gCheckOutIconHandle;extern Point			glastWhere;extern long				glastWhen;extern Rect				gCheckInRect, gCheckOutRect;extern ListHandle		gMachineList;extern char				gFeatureFlag; 			/*Keeps information about:												bit 0:database checking on/off												bit 1:teachin on/off*/void PrintComputerStatus(void){	THPrint 		printRecordH;	computerRecord 	sortedList[100];	Str255			computerNumberString, timeOn, s, converter;	short			computerNumber = 0;	TPPrPort			printPort;	Rect			printRect;	FontInfo		fInfo;	short			lineHeight, pageCount = 0, maxLineCount, counter, pageCounter, prError;	double			temp1,temp2;	GrafPtr			oldPort;	TPrStatus		theStatus;	long			numberofMachines;	computerRecPtr			theComputer;	double			theMod;		//inline double fmod(double x, double y);		GetPort(&oldPort);		numberofMachines = GetNumberofMachines();		/* make a copy of the gComputerRecord to sort */		LockMachineRecordHdl();	for(counter = 0; counter < numberofMachines; counter ++) /* make a copy of the gComputerRecord to sort */	{		theComputer = GetMachineRecord(counter);		memcpy(&sortedList[counter], theComputer, sizeof(computerRecord));	}	UnLockMachineRecordHdl();			/* sort the list */		qsort(sortedList, numberofMachines, sizeof(sortedList[0]), compareIt);		printRecordH = (THPrint) NewHandle(sizeof(TPrint));		PrOpen();		prError = PrError();		PrintDefault(printRecordH);		prError = PrError();		if(!PrStlDialog(printRecordH))	{		prError = PrError();		PrClose();		DisposHandle((Handle) printRecordH);		return;	}		if(!PrJobDialog(printRecordH))	{		prError = PrError();		PrClose();		DisposHandle((Handle) printRecordH);		return;	}		printPort = PrOpenDoc(printRecordH, nil, nil);		TextSize(10);	TextFont(monaco);		GetFontInfo(&fInfo);	lineHeight = fInfo.ascent + fInfo.descent + fInfo.leading;		printRect = (**printRecordH).prInfo.rPage;		maxLineCount = (printRect.bottom - printRect.top) / lineHeight;		theMod = fmod((double) numberofMachines, (double) maxLineCount);		if( theMod > 0)		pageCount ++;		pageCount =+ (numberofMachines / maxLineCount);		for(pageCounter = 0; pageCounter <= pageCount; pageCounter ++)	{		MoveTo(0,0);				PrOpenPage(printPort, nil);					TextSize(10);		TextFont(monaco);					for(counter = 0; counter <= maxLineCount; counter ++)		{						IUTimeString(sortedList[computerNumber].timeOn, 0, timeOn);			PtoCstr(timeOn);						if (!BitTst(&sortedList[computerNumber].status, kComputerInUse))			{				if (!BitTst(&sortedList[computerNumber].status, kComputerWorking))				{					sprintf((char *) s,"%.3d    Machine Down", sortedList[computerNumber].number);				}				else if (BitTst(&sortedList[computerNumber].status, kTeachingSet))				{					sprintf((char *) s,"%.3d    Used for Class", sortedList[computerNumber].number);				}				else				{					sprintf((char *) s,"%.3d    Machine Free", sortedList[computerNumber].number);				}			}			else if(BitTst(&sortedList[computerNumber].userInfo.status, UserTypeBit))			{				strncpy((char *) converter, sortedList[computerNumber].userInfo.name, 30);								sprintf((char *) s,"%.3d    %.10s    %d    %s", sortedList[computerNumber].number,											 		converter,											 		sortedList[computerNumber].userInfo.priority,											 		timeOn);							}			else			{					NumToString(sortedList[computerNumber].userInfo.studentNumber, converter);				PtoCstr(converter);								sprintf((char *) s,"%.3d    %.10s    %d    %s", sortedList[computerNumber].number,											 		converter,											 		sortedList[computerNumber].userInfo.priority,											 		timeOn);			}						CtoPstr((char *) s);						MoveTo(printRect.left, printRect.top + (lineHeight * counter));			DrawString(s);						if(computerNumber < (numberofMachines - 1))				computerNumber ++;			else				break;		}				PrClosePage(printPort);	}		PrCloseDoc(printPort);		if((**printRecordH).prJob.bJDocLoop == bSpoolLoop && !PrError())		PrPicFile(printRecordH, nil, nil, nil, &theStatus);		PrClose();	DisposHandle((Handle) printRecordH);		SetPort(oldPort);}