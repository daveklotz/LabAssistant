#include "lab assistant.h"#include "interface.h"#include "database.h"#include <icons.h>#include <string.h>#include "mainMachineList.h"#include "computerIcons.h"#include "toolbar.h"#include "roomStatus.h"short						gHighlightedIcon = -1;extern toolBarIcon			**gToolBarIconRec;void DrawMainWindow(WindowPtr theWindow){	WindowPtr		oldPort;	computerRecPtr	theComputer;	long			numberofMachines, counter;	Rect			boxRect;	ListHandle		theList;		GetPort(&oldPort);	SetPort(theWindow);		MakeList();	theList = GetListHandle();	HLock((Handle) theList);	LUpdate((*theList)->port->visRgn, theList);		memcpy(&boxRect, &(*theList)->rView, sizeof(Rect));	HUnlock((Handle) theList);		boxRect.right += 15;	InsetRect(&boxRect, -2, -2);	Add3dRaised(&boxRect, true, false, true);		numberofMachines = GetNumberofMachines();		LockMachineRecordHdl();	for(counter = 0; counter < numberofMachines; counter ++)	{		theComputer = GetMachineRecord(counter);		DrawMachineIcon(theComputer);	}	UnLockMachineRecordHdl();		DrawRoomStatus();		DrawToolBar(theWindow);				SetPort(oldPort);	}long MyDragGrayRgn(RgnHandle dragRgn, Point startPt, myDragGrayRgnProcPtr procPtr, long actionProcRefCon){	RgnHandle	currDragRgn = NewRgn(), prevDragRgn = NewRgn();	Point		origPt, currPt, prevPt;	PenState	oldPen;	long		returnValue = 0L;		CopyRgn(dragRgn, currDragRgn);	GetPenState(&oldPen);	PenPat(&qd.gray);	PenMode(patXor);		currPt = prevPt = origPt = startPt;		while (StillDown())	{		GetMouse(&currPt);		if ((currPt.v != prevPt.v) || (currPt.h != prevPt.h)) 		{			prevPt = currPt;			if (!EmptyRgn(prevDragRgn)) 				FrameRgn(prevDragRgn);						if (procPtr) 			{				SetPenState(&oldPen);				procPtr(prevPt, actionProcRefCon);				PenPat(&qd.gray);				PenMode(patXor);			}						SubPt(origPt, &currPt);			CopyRgn(dragRgn, currDragRgn);			OffsetRgn(currDragRgn, currPt.h, currPt.v);			FrameRgn(currDragRgn);			CopyRgn(currDragRgn, prevDragRgn);		}	}		if (!EmptyRgn(prevDragRgn))		FrameRgn(prevDragRgn);		SubPt(origPt, &prevPt);	SetPenState(&oldPen);	DisposeRgn(currDragRgn);	DisposeRgn(prevDragRgn);		return (long) *((long *) &prevPt);}pascal void WhileDraging(Point thePoint, long theRefCon){		short			computerNumber;	computerRecPtr	theComputer;		theRefCon = 0;		LockMachineRecordHdl();		if(PointInComputer(thePoint, &computerNumber))	{			if(IsSelected(computerNumber))		{			UnLockMachineRecordHdl();			return;		}					if(gHighlightedIcon == computerNumber)		{			UnLockMachineRecordHdl();			return;		}				if(gHighlightedIcon == -1)		{			theComputer = GetMachineRecord(computerNumber);			if(BitTst(&theComputer->status, kSelected))			{					UnLockMachineRecordHdl();				return;				}			BitSet(&theComputer->status, kSelected);			DrawMachineIcon(theComputer);			gHighlightedIcon = computerNumber;			UnLockMachineRecordHdl();			return;		}				theComputer = GetMachineRecord(gHighlightedIcon);		if(BitTst(&theComputer->status, kSelected))		{			BitClr(&theComputer->status, kSelected);			DrawMachineIcon(theComputer);			gHighlightedIcon = computerNumber;		}				theComputer = GetMachineRecord(computerNumber);		if(BitTst(&theComputer->status, kSelected))		{				UnLockMachineRecordHdl();			return;		}		BitSet(&theComputer->status, kSelected);		DrawMachineIcon(theComputer);		gHighlightedIcon = computerNumber;		UnLockMachineRecordHdl();		return;		}		else	{			if(gHighlightedIcon == -1)		{				UnLockMachineRecordHdl();			return;		}				theComputer = GetMachineRecord(gHighlightedIcon);		if(!BitTst(&theComputer->status, kSelected))		{			UnLockMachineRecordHdl();			return;		}		BitClr(&theComputer->status, kSelected);				DrawMachineIcon(theComputer);		gHighlightedIcon = -1;		UnLockMachineRecordHdl();	}		UnLockMachineRecordHdl();}/*******************************************************************		void Add3dRaised(Rect destRect, Boolean chiseled, Boolean whiteBackground)--------------------------------------------------------------------SYNOPSIS: This routine draws a 3D look to a Rect.CALLED BY: PASS: Rect destRect             : location to add 3D effect      Boolean chiseled          : create a chiseled look      Boolean whiteBackground   : unimplementedRETURN: nothing.REVISION HISTORY:	Name				Date		Description	----				----		-----------	Jeremy C Norberg	9/01/93		Initial version*********************************************************************/void Add3dRaised(Rect *destRect, Boolean chiseled, Boolean whiteBackground, Boolean blackBorder){	RGBColor		theColor, oldFrontColor, oldBackColor;	PixPatHandle	thePixPat;	Rect			blackBorderRect;		GetForeColor(&oldFrontColor);	GetBackColor(&oldBackColor);	if(blackBorder)	{		theColor.red = 0;		theColor.green = 0;		theColor.blue = 0;				memcpy(&blackBorderRect, destRect, sizeof(Rect));				InsetRect(&blackBorderRect, 1, 1);				FrameRect(&blackBorderRect); 	}			if(whiteBackground)	{		GetBackColor(&oldBackColor);		theColor.red = 65535;		theColor.green = 65535;		theColor.blue = 65535;				thePixPat = NewPixPat();		MakeRGBPat(thePixPat, &theColor);		memcpy(&blackBorderRect, destRect, sizeof(Rect));				InsetRect(&blackBorderRect, 2, 2);		HLock((Handle)thePixPat); 		FillCRect(&blackBorderRect, thePixPat);		DisposPixPat(thePixPat);		HUnlock((Handle)thePixPat);				RGBBackColor(&theColor);	}		if(chiseled)	{		theColor.red = medLightGray;		theColor.green = medLightGray;		theColor.blue = medLightGray;	}	else	{		theColor.red = colorWhite;		theColor.green = colorWhite;		theColor.blue = colorWhite;	}		RGBForeColor(&theColor);		MoveTo(destRect->left, destRect->top);	LineTo(destRect->left, destRect->bottom);		MoveTo(destRect->left, destRect->top);	LineTo(destRect->right, destRect->top);		if(chiseled)	{		theColor.red = colorWhite;		theColor.green = colorWhite;		theColor.blue = colorWhite;	}	else	{		theColor.red = medLightGray;		theColor.green = medLightGray;		theColor.blue = medLightGray;	}		RGBForeColor(&theColor);		MoveTo(destRect->right, destRect->top);	LineTo(destRect->right, destRect->bottom);		MoveTo(destRect->right, destRect->bottom);	LineTo(destRect->left, destRect->bottom);		RGBForeColor(&oldFrontColor);	RGBBackColor(&oldBackColor);}